* Point, Search Rectangle & Region functionality
*** Store and restore point

When two windows view the same buffer at the same time, and one
window is switched to another buffer and back, point is now the
same as in the other window, not as it was before we switched away.
This mode tries to work around this problem by storing and
restoring per-window positions for each buffer.

#+begin_src emacs-lisp :tangle no

(require 'winpoint)
(window-point-remember-mode 1)

#+end_src

*** I like returning to the same place

Purpose: When you visit a file, point goes to the last place where
  it was when you previously visited the same file.

To use it, turn it on in the options menu - “Save place in files
between Sessions”

#+begin_src emacs-lisp :tangle no

(require 'saveplace)                          ;; get the package

#+end_src

*** Goto last change - this is bodacious

#+begin_src emacs-lisp :tangle no

(when (require 'goto-last-change nil 'noerror)
  (global-set-key (kbd "C-x C-/") 'goto-last-change))

#+end_src

** Make script files executable automatically

You can force Emacs to make a file executable (respecting your umask
settings) if Emacs considers it a script. To determine if it is a
script, Emacs will look for the hash-bang notation in the file and
treat it as a script if it finds it.

Add this to your .emacs and Emacs will then make the file executable
if it is a script.

#+begin_src emacs-lisp :tangle no

(add-hook 'after-save-hook
  'executable-make-buffer-file-executable-if-script-p)

#+end_src


** Rotate text

#+begin_src emacs-lisp :tangle no

(require 'rotate-text)
(autoload 'rotate-text "rotate-text" nil t)
(autoload 'rotate-text-backward "rotate-text" nil t)

#+end_src

** artbollocks

#+begin_src emacs-lisp :tangle no

(if (require 'artbollocks-mode nil t)
    (progn
      (setq weasel-words-regex
            (concat "\\b" (regexp-opt
                           '("one of the"
                             "should"
                             "just"
                             "sort of"
                             "a lot"
                             "probably"
                             "maybe"
                             "perhaps"
                             "I think"
                             "really"
                             "pretty"
                             "maybe"
                             "nice"
                             "action"
                             "utilize"
                             "leverage") t) "\\b"))
      ;; Fix a bug in the regular expression to catch repeated words
      (setq lexical-illusions-regex "\\b\\(\\w+\\)\\W+\\(\\1\\)\\b")
      ;; Don't show the art critic words, or at least until I figure
      ;; out my own jargon
      (setq artbollocks nil)
      (add-hook 'org-capture-mode-hook 'artbollocks-mode)

      ))

#+end_src


** Kill Ring
*** Kill Ring

#+begin_src emacs-lisp :tangle no


(global-set-key (kbd "C-M-y") '(lambda ()
   (interactive)
   (popup-menu 'yank-menu)))

(require 'second-sel)



#+end_src

*** Undo-tree

#+begin_src emacs-lisp :tangle no

(require 'undo-tree)
(global-undo-tree-mode 1)

(defalias 'redo 'undo-tree-redo)

(global-set-key (kbd "C-z") 'undo) ; 【Ctrl+z】
(global-set-key (kbd "C-S-z") 'redo) ; 【Ctrl+Shift+z】

#+end_src

*** Kill ring hook

#+begin_src emacs-lisp :tangle no

(add-hook 'before-revert-hook  (lambda () (kill-ring-save (point-min) (point-max))))

#+end_src

** electric-pair-mode



new minor mode electric-pair-mode. When on, typing any left bracket
automatically insert the right matching bracket. Brackets includes the
ASCII ones: ""''(){}[], but also any unicode ones: «»‹›“”‘’「」『』〈〉
《》〔〕…. (➲ Matching Brackets in Unicode)


#+begin_src emacs-lisp :tangle no

(electric-pair-mode)

#+end_src


Deleting one bracket doesn't delete the other. (If you want that,
install autopairs package. (➲ A Guide on Emacs Package System))

Exactly which brackets are auto-closed depends on the current major
mode's syntax table. ((info "(elisp) Syntax Tables"))

If you always want certain brackets be inserted in pairs, you can
customize the variable “electric-pair-pairs”. Its value should be a
Association List. ((info "(elisp) Association Lists"))

For example, the double curly bracket isn't auto-closed when in
text-mode. But if you put the following in your emacs init:

#+begin_src emacs-lisp :tangle no

(global-set-key (kbd "C-H-'") "“")     ; insert opening double curly bracket by keypad 8

;; setting for auto-close brackets for electric-pair-mode regardless of current major mode syntax table
(setq electric-pair-pairs '(
                            (?\" . ?\")
                            (?\“ . ?\”)
                            (?\‘ . ?\’)
                            ) )



#+end_src

Now type 8 on keypad, it'll insert opening curly bracket, and the
matching one will be automatically closed by electric-pair-mode.

* Org (Organize your life)
** Org Latex

#+begin_src emacs-lisp

(require 'org-latex)
(unless (boundp 'org-export-latex-classes)
  (setq org-export-latex-classes nil))
(add-to-list 'org-export-latex-classes
             '("article"
               "\\documentclass{article}"
               ("\\section{%s}" . "\\section*{%s}")))

(add-to-list 'org-export-latex-classes
             '("article"
               "\\documentclass{article}"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

(add-to-list 'org-export-latex-classes
             `("book"
               "\\documentclass{book}"
               ("\\part{%s}" . "\\part*{%s}")
               ("\\chapter{%s}" . "\\chapter*{%s}")
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
             )

(add-to-list 'org-export-latex-classes
      '("org-article"
         "\\documentclass{org-article}
         [NO-DEFAULT-PACKAGES]
         [PACKAGES]
         [EXTRA]"
         ("\\section{%s}" . "\\section*{%s}")
         ("\\subsection{%s}" . "\\subsection*{%s}")
         ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
         ("\\paragraph{%s}" . "\\paragraph*{%s}")
         ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

(add-to-list 'org-export-latex-classes
          '("koma-article"
             "\\documentclass{scrartcl}
             [NO-DEFAULT-PACKAGES]
             [EXTRA]"
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
             ("\\paragraph{%s}" . "\\paragraph*{%s}")
             ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

(setq org-export-latex-listings 'minted)
(setq org-export-latex-custom-lang-environments
      '(
       (emacs-lisp "common-lispcode")
        ))
(setq org-export-latex-minted-options
      '(("frame" "lines")
        ("fontsize" "\\scriptsize")
        ("linenos" "")))
(setq org-latex-to-pdf-process
      '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))

(setq org-export-latex-listings 'listings)
(setq org-export-latex-custom-lang-environments
      '((emacs-lisp "common-lispcode")))
(setq org-export-latex-listings-options
      '(("frame" "lines")
        ("basicstyle" "\\footnotesize")
        ("numbers" "left")
        ("numberstyle" "\\tiny")))
(setq org-latex-to-pdf-process
      '("pdflatex -interaction nonstopmode -output-directory %o %f"
      "pdflatex -interaction nonstopmode -output-directory %o %f"
      "pdflatex -interaction nonstopmode -output-directory %o %f"))
(org-add-link-type
 "latex" nil
 (lambda (path desc format)
   (cond
    ((eq format 'html)
     (format "<span class=\"%s\">%s</span>" path desc))
    ((eq format 'latex)
     (format "\\%s{%s}" path desc)))))

#+end_src

** org subtree cut function
#+begin_src emacs-lisp

(define-key org-mode-map (kbd "C-c k") 'org-cut-subtree)

(setq org-export-with-section-numbers nil)
(setq org-html-include-timestamps nil)

(defun sacha/org-export-subtree-as-html-fragment ()
  (interactive)
  (org-export-region-as-html
   (org-back-to-heading)
   (org-end-of-subtree)
   t))

(setq org-link-abbrev-alist
  '(("google" . "http://www.google.com/search?q=")
    ("gmap" . "http://maps.google.com/maps?q=%s")
    ("blog" . "http://sachachua.com/blog/p/")))

#+end_src

** org-bable
#+begin_src emacs-lisp

(org-babel-do-load-languages
    'org-babel-load-languages '((python . t) (R . t) (perl . t)))

#+end_src

** org Jira

#+begin_src emacs-lisp

(add-to-list 'load-path (concat user-emacs-directory "elpa/jira-0.3.3"))

(require 'jira)
(setq jira-url "https://cuboulder.atlassian.net//rpc/xmlrpc")


;; you need make sure whether the "/jira" at the end is
;; necessary or not, see discussion at the end of this page


(add-to-list 'load-path "~/.emacs.d/site-lisp/org-jira")
(require 'org-jira)
(setq jiralib-url "https://cuboulder.atlassian.net")
;; jiralib is not explicitly required, since org-jira will load it.

(setq org-jira-working-dir "~/git/dkh-org/.org-jira")




#+end_src

* Navigation (Driving the car)
** Ibuffer

#+begin_src emacs-lisp :tangle no



                                        ; default groups for ibuffer
;; http://www.shellarchive.co.uk/content/emacs_tips.html#sec17


;; ibuffer, I like my buffers to be grouped
(add-hook 'ibuffer-mode-hook
          (lambda ()
            (ibuffer-switch-to-saved-filter-groups
             "default")))


;; Switching to ibuffer puts the cursor on the most recent buffer
(defadvice ibuffer (around ibuffer-point-to-most-recent) ()
  "Open ibuffer with cursor pointed to most recent buffer name"
  (let ((recent-buffer-name (buffer-name)))
    ad-do-it
    (ibuffer-jump-to-buffer recent-buffer-name)))
(ad-activate 'ibuffer)

(setq ibuffer-show-empty-filter-groups nil)

(defadvice ibuffer-generate-filter-groups (after reverse-ibuffer-groups ()
                                                 activate)
  (setq ad-return-value (nreverse ad-return-value)))

(setq ibuffer-restore-window-config-on-quit t)

;; Enable ibuffer-filter-by-filename to filter on directory names too.
(eval-after-load "ibuf-ext"
  '(define-ibuffer-filter filename
     "Toggle current view to buffers with file or directory name matching QUALIFIER."
     (:description "filename"
      :reader (read-from-minibuffer "Filter by file/directory name (regexp): "))
     (ibuffer-awhen (or (buffer-local-value 'buffer-file-name buf)
                        (buffer-local-value 'dired-directory buf))
       (string-match qualifier it))))

#+end_src

** Iswitchb

#+begin_src emacs-lisp :tangle no

;; iswitchb ignores
;;============================================================
(add-to-list 'iswitchb-buffer-ignore "^ ")
(add-to-list 'iswitchb-buffer-ignore "*Messages*")
(add-to-list 'iswitchb-buffer-ignore "*ECB")
(add-to-list 'iswitchb-buffer-ignore "*Buffer")
(add-to-list 'iswitchb-buffer-ignore "*Completions")
(add-to-list 'iswitchb-buffer-ignore "*ftp ")
(add-to-list 'iswitchb-buffer-ignore "*bsh")
(add-to-list 'iswitchb-buffer-ignore "*jde-log")
(add-to-list 'iswitchb-buffer-ignore "^[tT][aA][gG][sS]$")

#+end_src


** IDO

#+begin_src emacs-lisp :tangle no

;; ido makes competing buffers and finding files easier
;; http://www.emacswiki.org/cgi-bin/wiki/InteractivelyDoThings

(setq
  ido-save-directory-list-file "~/.emacs.d/ido.last"
)

(set `ido-ignore-files '("\\`CVS/" "\\`#" "\\`.#" "\\`\\.\\./"
"\\`\\./" "\\.el?$"))

(setq ido-ignore-buffers
  '("\\` " "^\*Mess" "^\*Back" ".*Completions" "^\*Ido" "^\*trace"
     "^\*compilation" "^\*GTAGS" "^session\.*" "^\*" "^\\*Completions\\*$"))

(setq  ido-work-directory-list '("~/git" "~/.emacs.d" "~/docs" ))



(setq  ido-case-fold  t                 ; be case-insensitive
  ido-enable-last-directory-history t ; remember last used dirs
  ido-max-work-directory-list 30   ; should be enough
  ido-max-work-file-list      50   ; remember many
)

(setq ido-use-filename-at-point 'guess)

(setq ido-use-url-at-point nil)         ; don't use url at point (annoying)

(setq ido-enable-flex-matching t)   ; don't try to be too smart

(setq ido-max-prospects 8)              ; don't spam my minibuffer

(setq  ido-confirm-unique-completion t) ; wait for RET, even with unique completion

;; when using ido, the confirmation is rather annoying...
(setq confirm-nonexistent-file-or-buffer nil)

                                          ; 50 files ought to be enough.
  (setq recentf-max-saved-items 50)

  (defun ido-recentf-open ()
    "Use `ido-completing-read' to \\[find-file] a recent file"
    (interactive)
    (if (find-file (ido-completing-read "Find recent file: " recentf-list))
        (message "Opening file...")
      (message "Aborting")))

                                          ; IDO switch between irc channels.

;; get rid of `find-file-read-only' and replace it with something
  ;; more useful.
  (global-set-key (kbd "C-x C-r") 'ido-recentf-open)

(setq ido-create-new-buffer 'always)

(setq ido-file-extensions-order '(".org" ".php" ".txt" ".py" ".xml" ".el" ".ini" ".cfg" ".cnf"))

(defun rgr/ido-erc-buffer()
(interactive)
(switch-to-buffer
 (ido-completing-read "Channel:"
                      (save-excursion
                        (delq
                         nil
                         (mapcar (lambda (buf)
                                   (when (buffer-live-p buf)
                                     (with-current-buffer buf
                                       (and (eq major-mode 'erc-mode)
                                            (buffer-name buf)))))
                                 (buffer-list)))))))

(defun ido-find-file-in-tag-files ()
  (interactive)
  (save-excursion
    (let ((enable-recursive-minibuffers t))
      (visit-tags-table-buffer))
    (find-file
     (expand-file-name
      (ido-completing-read
       "Project file: " (tags-table-files) nil t)))))

(lambda (x) (and (string-match-p "^\\.." x) x))

(lambda (a b)
      (let ((a-tramp-file-p (string-match-p ":\\'" a))
            (b-tramp-file-p (string-match-p ":\\'" b)))
        (cond
         ((and a-tramp-file-p b-tramp-file-p)
          (string< a b))
         (a-tramp-file-p nil)
         (b-tramp-file-p t)
         (t (time-less-p
             (sixth (file-attributes (concat ido-current-directory b)))
             (sixth (file-attributes (concat ido-current-directory a))))))))

(setq ido-enable-tramp-completion nil)

(setq ido-use-virtual-buffers 't)

(add-to-list 'ido-work-directory-list-ignore-regexps tramp-file-name-regexp)

(setq ido-default-buffer-method 'selected-window)

(add-hook 'ido-make-file-list-hook 'ido-sort-mtime)
    (add-hook 'ido-make-dir-list-hook 'ido-sort-mtime)

(defun ido-sort-mtime ()
      (setq ido-temp-list
            (sort ido-temp-list
                  (lambda (a b)
                    (let ((ta (nth 5 (file-attributes (concat ido-current-directory a))))
                          (tb (nth 5 (file-attributes (concat ido-current-directory b)))))
                      (if (= (nth 0 ta) (nth 0 tb))
                          (> (nth 1 ta) (nth 1 tb))
                        (> (nth 0 ta) (nth 0 tb)))))))
      (ido-to-end  ;; move . files to end (again)
       (delq nil (mapcar
                  (lambda (x) (if (string-equal (substring x 0 1) ".") x))
                  ido-temp-list))))

#+end_src

** Find file as root function(s)

#+begin_src emacs-lisp :tangle no

(defun find-file-as-root ()
  "Find a file as root."
  (interactive)
  (let* ((parsed (when (tramp-tramp-file-p default-directory)
                   (coerce (tramp-dissect-file-name default-directory)
                           'list)))
         (default-directory
           (if parsed
               (apply 'tramp-make-tramp-file-name
                      (append '("sudo" "root") (cddr parsed)))
             (tramp-make-tramp-file-name "sudo" "root" "localhost"
                                         default-directory))))
    (call-interactively 'find-file)))

(defun toggle-alternate-file-as-root (&optional filename)
  "Toggle between the current file as the default user and as root."
  (interactive)
  (let* ((filename (or filename (buffer-file-name)))
         (parsed (when (tramp-tramp-file-p filename)
                   (coerce (tramp-dissect-file-name filename)
                           'list))))
    (unless filename
      (error "No file in this buffer."))

    (find-alternate-file
     (if (equal '("sudo" "root") (butlast parsed 2))
         ;; As non-root
         (if (or
              (string= "localhost" (nth 2 parsed))
              (string= (system-name) (nth 2 parsed)))
             (car (last parsed))
           (apply 'tramp-make-tramp-file-name
                  (append (list tramp-default-method nil) (cddr parsed))))

       ;; As root
       (if parsed
           (apply 'tramp-make-tramp-file-name
                  (append '("sudo" "root") (cddr parsed)))
         (tramp-make-tramp-file-name "sudo" nil nil filename))))))

(defun th-find-file-sudo (file)
  "Opens FILE with root privileges."
  (interactive "F")
  (set-buffer (find-file (concat "/sudo::" file))))

(defadvice find-file (around th-find-file activate)
  "Open FILENAME using tramp's sudo method if it's read-only."
  (if (and (not (file-writable-p (ad-get-arg 0)))
       (not (file-remote-p (ad-get-arg 0)))
       (y-or-n-p (concat "File "
                 (ad-get-arg 0)
                 " is read-only.  Open it as root? ")))
      (th-find-file-sudo (ad-get-arg 0))
    ad-do-it))

#+end_src

** filecache

#+begin_src emacs-lisp :tangle no

(require 'filecache)

(defun file-cache-ido-find-file (file)
  "Using ido, interactively open file from file cache'.
First select a file, matched using ido-switch-buffer against the contents
in `file-cache-alist'. If the file exist in more than one
directory, select directory. Lastly the file is opened."
  (interactive (list (file-cache-ido-read "File: "
                                          (mapcar
                                           (lambda (x)
                                             (car x))
                                           file-cache-alist))))
  (let* ((record (assoc file file-cache-alist)))
    (find-file
     (expand-file-name
      file
      (if (= (length record) 2)
          (car (cdr record))
        (file-cache-ido-read
         (format "Find %s in dir: " file) (cdr record)))))))

(defun file-cache-ido-read (prompt choices)
  (let ((ido-make-buffer-list-hook
         (lambda ()
           (setq ido-temp-list choices))))
    (ido-read-buffer prompt)))
(add-to-list 'file-cache-filter-regexps "docs/html")
(add-to-list 'file-cache-filter-regexps "\\.svn-base$")
(add-to-list 'file-cache-filter-regexps "\\.dump$")

#+end_src

** Imenu

#+begin_src emacs-lisp :tangle no

(setq imenu-auto-rescan 't)

#+end_src

** Smex
smex-save-file is a variable defined in `smex.el'.

#+begin_src emacs-lisp :tangle no

(setq smex-save-file "~/.emacs.d/.smex-items")

#+end_src

** Registers

#+TITLE:   Starter Kit Registers
#+OPTIONS: toc:nil num:nil ^:nil

*** Starter Kit Registers
Registers allow you to jump to a file or other location quickly. Use
=C-x r j= followed by the letter of the register (i for =init.el=, s
for this file) to jump to it.

You should add registers here for the files you edit most often.

#+srcname: starter-kit-registers

Documentation:
Alist of elements (NAME . CONTENTS), one for each Emacs register.
NAME is a character (a number).  CONTENTS is a string, number, marker, list
or a struct returned by `registerv-make'.
A list of strings represents a rectangle.
A list of the form (file . FILE-NAME) represents the file named FILE-NAME.
A list of the form (file-query FILE-NAME POSITION) represents
 position POSITION in the file named FILE-NAME, but query before
 visiting it.
A list of the form (WINDOW-CONFIGURATION POSITION)
 represents a saved window configuration plus a saved value of point.
A list of the form (FRAME-CONFIGURATION POSITION)
 represents a saved frame configuration plus a saved value of point.
;; (cond ((file-exists-p (expand-file-name "~/work/rldev")

#+begin_src emacs-lisp

(dolist (r `( (?e (file . "~/git/ewax/dkh-core.org"))))
             (set-register (car r) (cadr r)))

#+end_src



* Documentation
** Self-documentation
*** Which func mode

Which-func is a minor-mode that will add the function point is inside
to the mode-line. This is mainly useful if you are looking at large
functions, but it could also be nice if you use vertical
splits. Which-func mode is built into emacs, so you have to go through
very little work to enable it.

This package prints name of function where your current point is
located in mode line. It assumes that you work with imenu package and
imenu--index-alist is up to date.

#+begin_src emacs-lisp :tangle no

(which-function-mode t)
(setq which-func-modes t)
(which-func-mode 1)

#+end_src

*** Man

#+begin_src emacs-lisp :tangle no
(setq Man-switches "-a")

(defadvice Man-build-page-list (after reverse-page-list activate)
  (setq Man-page-list (nreverse Man-page-list)))

#+end_src

*** 25.16 Using (info "(emacs)Dialog Boxes")

Don't use dialog boxes to ask questions

#+begin_src emacs-lisp :tangle no

(setq use-dialog-box nil)

#+end_src

Don't use a file dialog to ask for files

#+begin_src emacs-lisp :tangle no

(setq use-file-dialog nil)

#+end_src

** Google Definitions

#+begin_src emacs-lisp :tangle no

(require 'mm-url)
(defun google-define-word-or-phrase (query)
  (interactive "sInsert word or phrase to search: ")
  (let* ((url (concat "http://www.google.com.pe/search?hl=en&q=define%3A"
              (replace-regexp-in-string " " "+" query)))
     (definition
       (save-excursion
         (with-temp-buffer
           (mm-url-insert url)
           (goto-char (point-min))
           (if (search-forward "No definitions found of " nil t)
           "No definitions found"
         (buffer-substring (search-forward "<li>") (- (search-forward "<") 1)))))))
    (message "%s: %s" query definition)))

#+end_src

** Eldoc

#+begin_src emacs-lisp :tangle no

(eldoc-mode t)

#+end_src


* Utilities (tools)

** Tramp

*** General

#+begin_src emacs-lisp :tangle no

(setq tramp-default-method "ssh")

(setq tramp-default-user "username")

(setq tramp-debug-buffer t)
(setq tramp-verbose 10)

(setq password-cache nil)
;;(setq password-cache-expiry nil)

(setq tramp-backup-directory-alist backup-directory-alist)


#+end_src

*** Clean up tramp before saving desktop

#+begin_src emacs-lisp :tangle no

(add-hook 'desktop-save-hook 'tramp-cleanup-all-buffers)



#+end_src

** Shells

*** Shell

Make Emacs Always Start a New Shell

In GNU Emacs, to start a second shell interface, call shell by first typing 【
Ctrl+u】.

Ellen Taylor provided the following code, which makes shell command always
start a new shell.

#+begin_src emacs-lisp

;; by Ellen Taylor, 2012-07-20
(defadvice shell (around always-new-shell)
  "Always start a new shell."
  (let ((buffer (generate-new-buffer-name "*shell*"))) ad-do-it))

(ad-activate 'shell)

#+end_src



*** AnsiTerm

In the above mentioned article Joseph wrote a nice little bit of elisp
to get to a running ansi-term efficiently, by hitting F2. The nice
thing about it is that it does what I mean:

 1. If I'm already in an ansi-term, but it's called "*ansi-term*"
    rename it.
 2. If I'm already in an ansi-term, but it's called something else,
    start a new ansi-term called "*ansi-term*"
 3. If I'm in another non-terminal buffer, switch to a buffer called
    "*ansi-term*" or create a new one if it doesn't exist

There's one more catch though, as Joseph explains, an ansi-term can be
considered "stopped" such that it is no longer running but the buffer
still exists. In that case I don't want the third rule to switch me to
a defunct terminal, so instead I want it to kill the buffer and create
a new ansi-term. Here is my enhanced elisp:

#+begin_src emacs-lisp :tangle no

(defun visit-ansi-term ()
  (interactive)
  "Creates an ansi-term and switches to it. If a buffer with name already exists, we simply switch to it."
  (let ((buffer-of-name (get-buffer (concat "*ansi-term-" (wg-name (wg-current-workgroup)))))
;;        (default-directory "/home/www")
        (term-cmd "/bin/zsh")
)
    (cond ((bufferp buffer-of-name) ;If the buffer exists, switch to it (assume it is a shell)
           (switch-to-buffer buffer-of-name))
          ( t
            (progn
              (ansi-term term-cmd)
              ;(process-send-string (get-buffer-process new-buff-name) (concat "cd " localdir "\n"))
              (rename-buffer  (concat "*ansi-term-" (wg-name (wg-current-workgroup)))))))))

;;(global-set-key (kbd "C-8 a") 'visit-ansi-term)

#+end_src

#+begin_src emacs-lisp :tangle no

(defun visit-devel ()
  (interactive)
  "Creates an ansi-term and switches to it. If a buffer with name already exists, we simply switch to it."
  (let ((buffer-of-name (get-buffer (concat "*ansi-term-" (wg-name (wg-current-workgroup)))))
        (default-directory "/Users/daha1836/data/releases/fit/master")
        (term-cmd "/bin/zsh")
)
    (cond ((bufferp buffer-of-name) ;If the buffer exists, switch to it (assume it is a shell)
           (switch-to-buffer buffer-of-name))
          ( t
            (progn
              (ansi-term term-cmd)
              ;(process-send-string (get-buffer-process new-buff-name) (concat "cd " localdir "\n"))
              (rename-buffer  (concat "*ansi-term-" (wg-name (wg-current-workgroup)))))))))
#+end_src


Localhost

For terminal emulation on the local host, this simple function names
the buffers *localhost*, *localhost<2>*, etc…

#+begin_src emacs-lisp :tangle no

(defun open-localhost ()
  (interactive)
  (ansi-term "bash" "localhost"))


(defun open-localhost ()
  (interactive)
  (ansi-term "bash" "localhost"))

#+end_src

For remote hosts, an additional function was required since the
ansi-term command doesn’t support additional arguments:

#+begin_src emacs-lisp :tangle no

;; Use this for remote so I can specify command line arguments
(defun remote-term (new-buffer-name cmd &rest switches)
  (setq term-ansi-buffer-name (concat "*" new-buffer-name "*"))
  (setq term-ansi-buffer-name (generate-new-buffer-name term-ansi-buffer-name))
  (setq term-ansi-buffer-name (apply 'make-term term-ansi-buffer-name cmd nil switches))
  (set-buffer term-ansi-buffer-name)
  (term-mode)
  (term-char-mode)
  (term-set-escape-char ?\C-x)
  (switch-to-buffer term-ansi-buffer-name))

#+end_src

You can then define a new function in your init file for each host you
frequently visit with it’s own buffer name and connection parameters:

#+begin_src emacs-lisp :tangle no

(defun open-prod ()
  (interactive)
  (remote-term (concat "ansi-term-" (wg-name (wg-current-workgroup)) ) "ssh" "user@prod.domain.com"))

(defun open-stage ()
  (interactive)
  (remote-term (concat "ansi-term-" (wg-name (wg-current-workgroup)) ) "ssh" "user@host-staging.domain.com"))

(defun open-test ()
  (interactive)
  (remote-term (concat "ansi-term-" (wg-name (wg-current-workgroup)) ) "ssh" "user@localhost"))


(defun open-devel ()
  (interactive)
  (remote-term (concat "ansi-term-" (wg-name (wg-current-workgroup)) ) "ssh" "user@localhost"))


(defun git-fit ()
(interactive)
(magit-status
(getenv "FIT_REPO")))

;;(global-set-key (kbd "C-8 g") 'git-fit)


(global-set-key (kbd "C-x <f6>") 'visit-devel)
(global-set-key (kbd "C-x <f7>") 'open-test)
(global-set-key (kbd "C-x <f8>") 'open-stage)
(global-set-key (kbd "C-x <f9>") 'open-prod)

#+end_src

*** Shell functions

#+begin_src emacs-lisp :tangle no

(defun shell-command-on-region-to-string (start end command)
  (with-output-to-string
    (shell-command-on-region start end command standard-output)))

(defun shell-command-on-region-with-output-to-end-of-buffer (start end command)
  (interactive
   (let ((command (read-shell-command "Shell command on region: ")))
     (if (use-region-p)
         (list (region-beginning) (region-end) command)
       (list (point-min) (point-max) command))))
  (save-excursion
    (goto-char (point-max))
    (insert (shell-command-on-region-to-string start end command))))

(defun shell-here ()
  "Open a shell in `default-directory'."
  (interactive)
  (let ((dir (expand-file-name default-directory))
        (buf (or (get-buffer "*shell*") (shell))))
    (goto-char (point-max))
    (if (not (string= (buffer-name) "*shell*"))
        (switch-to-buffer-other-window buf))
    (message list-buffers-directory)
    (if (not (string= (expand-file-name list-buffers-directory) dir))
        (progn (comint-send-string (get-buffer-process buf)
                                   (concat "cd \"" dir "\"\r"))
               (setq list-buffers-directory dir)))))

(setq ansi-color-names-vector
      ["black" "tomato" "PaleGreen2" "gold1"
       "DeepSkyBlue1" "MediumOrchid1" "cyan" "white"])

(setq ansi-color-map (ansi-color-make-color-map))

(add-hook 'shell-mode-hook
     '(lambda () (toggle-truncate-lines 1)))
(setq comint-prompt-read-only t)

(defvar my-local-shells
  '("*shell0*" "*shell1*" "*shell2*" "*shell3*" "*music*"))
(defvar my-remote-shells
  '("*dhaley*" "*pup*" "*pup-staging*" "*heaven2*" "*heaven3*"))
(defvar my-shells (append my-local-shells my-remote-shells))

(custom-set-variables
 '(comint-scroll-to-bottom-on-input t)  ; always insert at the bottom
 ;; '(comint-completion-autolist t)     ; show completion list when ambiguous
 '(comint-input-ignoredups t)           ; no duplicates in command history
 '(comint-buffer-maximum-size 20000)    ; max length of the buffer in lines
 '(comint-prompt-read-only nil)         ; if this is t, it breaks shell-command
 '(comint-get-old-input (lambda () "")) ; what to run when i press enter on a
                                        ; line above the current prompt
 '(protect-buffer-bury-p nil)
)

;; truncate buffers continuously
(add-hook 'comint-output-filter-functions 'comint-truncate-buffer)

(defun make-my-shell-output-read-only (text)
  "Add to comint-output-filter-functions to make stdout read only in my shells."
  (if (member (buffer-name) my-shells)
      (let ((inhibit-read-only t)
            (output-end (process-mark (get-buffer-process (current-buffer)))))
        (put-text-property comint-last-output-start output-end 'read-only t))))
(add-hook 'comint-output-filter-functions 'make-my-shell-output-read-only)

(defun my-dirtrack-mode ()
  "Add to shell-mode-hook to use dirtrack mode in my shell buffers."
  (when (member (buffer-name) my-shells)
    (shell-dirtrack-mode 0)
    (set-variable 'dirtrack-list '("^.*[^ ]+:\\(.*\\)>" 1 nil))
    (dirtrack-mode 1)))
(add-hook 'shell-mode-hook 'my-dirtrack-mode)

; interpret and use ansi color codes in shell output windows
(add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)

(defun set-scroll-conservatively ()
  "Add to shell-mode-hook to prevent jump-scrolling on newlines in shell buffers."
  (set (make-local-variable 'scroll-conservatively) 10))
(add-hook 'shell-mode-hook 'set-scroll-conservatively)

;; i think this is wrong, and it buries the shell when you run emacsclient from
;; it. temporarily removing.
;; (defun unset-display-buffer-reuse-frames ()
;;   "Add to shell-mode-hook to prevent switching away from the shell buffer
;; when emacsclient opens a new buffer."
;;   (set (make-local-variable 'display-buffer-reuse-frames) t))
;; (add-hook 'shell-mode-hook 'unset-display-buffer-reuse-frames)

(require 'protbuf)
(add-hook 'shell-mode-hook 'protect-process-buffer-from-kill-mode)


(defun make-comint-directory-tracking-work-remotely ()
  "Add this to comint-mode-hook to make directory tracking work
while sshed into a remote host, e.g. for remote shell buffers
started in tramp. (This is a bug fix backported from Emacs 24:
http://comments.gmane.org/gmane.emacs.bugs/39082"
  (set (make-local-variable 'comint-file-name-prefix)
       (or (file-remote-p default-directory) "")))
(add-hook 'comint-mode-hook 'make-comint-directory-tracking-work-remotely)

(defun enter-again-if-enter ()
  "Make the return key select the current item in minibuf and shell history isearch.
An alternate approach would be after-advice on isearch-other-meta-char."
  (when (and (not isearch-mode-end-hook-quit)
             (equal (this-command-keys-vector) [13])) ; == return
    (cond ((active-minibuffer-window) (minibuffer-complete-and-exit))
          ((member (buffer-name) my-shells) (comint-send-input)))))
(add-hook 'isearch-mode-end-hook 'enter-again-if-enter)

(defadvice comint-previous-matching-input
    (around suppress-history-item-messages activate)
  "Suppress the annoying 'History item : NNN' messages from shell history isearch.
If this isn't enough, try the same thing with
comint-replace-by-expanded-history-before-point."
  (let ((old-message (symbol-function 'message)))
    (unwind-protect
      (progn (fset 'message 'ignore) ad-do-it)
    (fset 'message old-message))))

(defadvice comint-send-input (around go-to-end-of-multiline activate)
  "When I press enter, jump to the end of the *buffer*, instead of the end of
the line, to capture multiline input. (This only has effect if
`comint-eol-on-send' is non-nil."
  (flet ((end-of-line () (end-of-buffer)))
    ad-do-it))

;; not sure why, but comint needs to be reloaded from the source (*not*
;; compiled) elisp to make the above advise stick.
(load "comint.el.gz")

;; for other code, e.g. emacsclient in TRAMP ssh shells and automatically
;; closing completions buffers, see the links above.

#+end_src


** Dired

** [[http://www.emacswiki.org/cgi-bin/wiki?DiredReuseDirectoryBuffer][Resuse directory buffer]]

#+begin_src emacs-lisp :tangle no

(put 'dired-find-alternate-file 'disabled nil)

#+end_src

** General

#+begin_src emacs-lisp :tangle no

;; enable the use of the command `dired-find-alternate-file'
;; without confirmation
(put 'dired-find-alternate-file 'disabled nil)

(add-hook 'dired-mode-hook
          (lambda ()
            (define-key dired-mode-map "b" 'my-browser-find-file)))

(defun my-dired-browser-find-file ()
  "Dired function to view a file in a web browser"
  (interactive)
  (browse-url (browse-url-file-url (dired-get-filename))))

(add-hook 'dired-load-hook (function (lambda () (load "dired-x"))))

;; (setq dired-omit-file "^\\.?#\\|^\\.$\\|^\\.\\.$")

(setq dired-omit-files
      (rx (or (seq bol (? ".") "#")         ;; emacs autosave files
              (seq "~" eol)                 ;; backup-files
              (seq bol "svn" eol)           ;; svn dirs
;;              (seq ".git" eol)
;;              (seq bol "." (not (any "."))) ;; dot-files
;;              (seq ".pyc" eol)
              )))
(setq dired-omit-extensions
      (append dired-latex-unclean-extensions
              dired-bibtex-unclean-extensions
              dired-texinfo-unclean-extensions))
(add-hook 'dired-mode-hook (lambda () (dired-omit-mode 1)))

(defun 2zip ()
  "Zip the current file/dir in `dired'.
If multiple files are marked, only zip the first one.
Require unix zip commandline tool."
  (interactive)
  (require 'dired)
  (let ( (fileName (elt (dired-get-marked-files) 0))  )
    (shell-command (format "zip -r '%s.zip' '%s'" (file-relative-name fileName) (file-relative-name fileName)))
    ))

(autoload 'dired-jump "dired-x" "Jump to dired corresponding current buffer.")
(autoload 'dired-jump-other-window "dired-x" "jump to dired in other window.")


(setq toggle-diredp-find-file-reuse-directory t)

#+end_src

* Custom functions
** Push to mark no activate

#+begin_src emacs-lisp :tangle no

(defun push-mark-no-activate ()
  "Pushes `point' to `mark-ring' and does not activate the region
  Equivalent to \\[set-mark-command] when \\[transient-mark-mode] is disabled"
  (interactive)
  (push-mark (point) t nil)
  (message "Pushed mark to ring"))
(global-set-key (kbd "C-,") 'push-mark-no-activate)

#+end_src

** Toggle Chrome

#+begin_src emacs-lisp :tangle no

(defun dkh/toggle-chrome ()
  "Show/hide toolbar and menubar."
  (interactive)
  (menu-bar-mode)
  (when (window-system)
    (tool-bar-mode)))

#+end_src

** Handle MS-Word

#+begin_src emacs-lisp :tangle no

;; this seems to enable MS-Word documents
 (defun mm-inline-msword (handle)
   (let (text)
     (with-temp-buffer
       (mm-insert-part handle)
       (call-process-region (point-min) (point-max) "antiword" t t nil "-")
       (setq text (buffer-string)))
     (mm-insert-inline handle text)))

#+end_src

** Switch or start

#+begin_src emacs-lisp :tangle no

;; stolen from old starter-kit
(defun switch-or-start (function buffer)
  "If the buffer is current, bury it, otherwise invoke the function."
  (if (equal (buffer-name (current-buffer)) buffer)
      (bury-buffer)
    (if (get-buffer buffer)
        (switch-to-buffer buffer)
      (funcall function))))

#+end_src

** Open with sudo if necessary

#+begin_src emacs-lisp :tangle no

(defun find-alternative-file-with-sudo ()
    "Open current buffer as root!"
    (interactive)
    (when buffer-file-name
      (find-alternate-file
       (concat "/sudo:root@localhost:"
               buffer-file-name))))

(global-set-key (kbd "C-x C-t") 'find-alternative-file-with-sudo)

#+end_src

** Opacity
#+begin_src emacs-lisp :tangle no

(defun djcb-opacity-modify (&optional dec)
  "modify the transparency of the emacs frame; if DEC is t,
    decrease the transparency, otherwise increase it in 10%-steps"
  (let* ((alpha-or-nil (frame-parameter nil 'alpha)) ; nil before setting
          (oldalpha (if alpha-or-nil alpha-or-nil 100))
          (newalpha (if dec (- oldalpha 10) (+ oldalpha 10))))
    (when (and (>= newalpha frame-alpha-lower-limit) (<= newalpha 100))
      (modify-frame-parameters nil (list (cons 'alpha newalpha))))))

 ;; C-8 will increase opacity (== decrease transparency)
 ;; C-9 will decrease opacity (== increase transparency
 ;; C-0 will returns the state to normal
(global-set-key (kbd "H-8") '(lambda()(interactive)(djcb-opacity-modify)))
(global-set-key (kbd "H-9") '(lambda()(interactive)(djcb-opacity-modify t)))
(global-set-key (kbd "H-0") '(lambda()(interactive)
                               (modify-frame-parameters nil `((alpha . 100)))))

#+end_src

** Bracket functions

#+begin_src emacs-lisp :tangle no
(defun forward-open-bracket ()
  "Move cursor to the next occurrence of left bracket or quotation mark."
  (interactive)
  (forward-char 1)
  (search-forward-regexp "(\\|{\\|\\[\\|<\\|〔\\|【\\|〖\\|〈\\|「\\|『\\|“\\|‘\\|‹\\|«")
  (backward-char 1)
  )

(defun backward-open-bracket ()
  "Move cursor to the previous occurrence of left bracket or quotation mark.."
  (interactive)
  (search-backward-regexp "(\\|{\\|\\[\\|<\\|〔\\|【\\|〖\\|〈\\|「\\|『\\|“\\|‘\\|‹\\|«")
  )

(defun forward-close-bracket ()
  "Move cursor to the next occurrence of right bracket or quotation mark."
  (interactive)
  (search-forward-regexp ")\\|\\]\\|}\\|>\\|〕\\|】\\|〗\\|〉\\|」\\|』\\|”\\| ’\\| ›\\| »")
 )

(defun backward-close-bracket ()
  "Move cursor to the next occurrence of right bracket or quotation mark."
  (interactive)
  (backward-char 1)
  (search-backward-regexp ")\\|\\]\\|}\\|>\\|〕\\|】\\|〗\\|〉\\|」\\|』\\|”\\| ’\\| ›\\| »")
  (forward-char 1)
  )

#+end_src

** Point functions

#+begin_src emacs-lisp :tangle no

(defun get-point (symbol &optional arg)
 "get the point"
 (funcall symbol rag)
 (point)
)

(defun copy-thing (begin-of-thing end-of-thing &optional arg)
  "copy thing between beg & end into kill ring"
   (save-excursion
     (let ((beg (get-point begin-of-thing 1))
        (end (get-point end-of-thing arg)))
       (copy-region-as-kill beg end)))
)

(defun paste-to-mark(&optional arg)
  "Paste things to mark, or to the prompt in shell-mode"
  (let ((pasteMe
    (lambda()
      (if (string= "shell-mode" major-mode)
        (progn (comint-next-prompt 25535) (yank))
      (progn (goto-char (mark)) (yank) )))))
   (if arg
       (if (= arg 1)
       nil
         (funcall pasteMe))
     (funcall pasteMe))
   ))

(defun copy-word (&optional arg)
 "Copy words at point into kill-ring"
  (interactive "P")
  (copy-thing 'backward-word 'forward-word rag)
  ;;(paste-to-mark rag)
)

;; (transient-mark-mode 1)

(defun select-current-line ()
  "Select the current line"
  (interactive)
  (end-of-line) ; move to end of line
  (set-mark (line-beginning-position)))

#+end_src

** Full screen function

#+begin_src emacs-lisp :tangle no

(defun toggle-fullscreen (&optional f)
  (interactive)
  (let ((current-value (frame-parameter nil 'fullscreen)))
       (set-frame-parameter nil 'fullscreen
                            (if (equal 'fullboth current-value)
                                (if (boundp 'old-fullscreen) old-fullscreen nil)
                                (progn (setq old-fullscreen current-value)
                                       'fullboth)))))

#+end_src

** Insert date function

#+begin_src emacs-lisp :tangle no

(defun insert-date ()
"Insert date at point."
(interactive)
(insert (format-time-string "%d.%m.%Y %H:%M")))

#+end_src

** dos 2 unix function(s)

#+begin_src emacs-lisp :tangle no

(defun dos-to-unix ()
  "Cut all visible ^M from the current buffer."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (while (search-forward "\r" nil t)
      (replace-match ""))))

(defun unix-to-dos ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (while (search-forward "\n" nil t)
      (replace-match "\r\n"))))

#+end_src

** rename file and buffer function

#+begin_src emacs-lisp :tangle no

(defun rename-file-and-buffer ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (message "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
        (cond ((get-buffer new-name)
               (message "A buffer named '%s' already exists!" new-name))
              (t
               (rename-file filename new-name 1)
               (rename-buffer new-name)
               (set-visited-file-name new-name)
               (set-buffer-modified-p nil)))))))

#+end_src

** Other functions

#+begin_src emacs-lisp :tangle no

(defun remove-dupes (list)
  (let (tmp-list head)
    (while list
      (setq head (pop list))
      (unless (equal head (car list))
        (push head tmp-list)))
    (reverse tmp-list)))

(defun assoc-replace (seq values)
  "Replace an element within an association list where the cars match."
  (mapcar (lambda (elem)
            (let* ((key (car elem))
                   (val (assoc key values)))
              (if val (cadr val) elem))) seq))

(defun duplicate-current-line ()
  (interactive)
  (beginning-of-line nil)
  (let ((b (point)))
    (end-of-line nil)
    (copy-region-as-kill b (point)))
  (beginning-of-line 2)
  (open-line 1)
  (yank)
  (back-to-indentation))

(defun duplicate-current-line (&optional n)
“duplicate current line, make more than 1 copy given a numeric argument”
(interactive “p”)
(save-excursion
(let ((nb (or n 1))
(current-line (thing-at-point ‘line)))
;; when on last line, insert a newline first
(when (or (= 1 (forward-line 1)) (eq (point) (point-max)))
(insert “\n”))

;; now insert as many time as requested
(while (> n 0)
(insert current-line)
(setq n (- n 1))))))

(global-set-key (kbd "C-S-d") 'duplicate-current-line)

(defun set-longlines-mode ()
  (interactive)
  (text-mode)
  (longlines-mode 1))

(defun regex-replace (regex string)
  (goto-char (point-min))
  (while (re-search-forward regex nil t)
    (replace-match string)))

(defun string-repeat (str n)
  (let ((retval ""))
    (dotimes (i n)
      (setq retval (concat retval str)))
    retval))

;;;###autoload

(defun grab-url-at-point-my ()
  (interactive)
  (kill-new (thing-at-point 'url)))

;;;###autoload

(defun grab-email-my ()
  "Grab the next email in the buffer
  First posted by François Fleuret <francois.fleuret@inria.fr>..
improved by many.."
  (interactive)
  (re-search-forward "[^ \t\n]+@[^ \t\n]+")
  (copy-region-as-kill (match-beginning 0) (match-end 0))
  )

(defun duplicate-line-or-region (&optional n)
  "Duplicate current line, or region if active.
With argument N, make N copies.
With negative N, comment out original line and use the absolute value."
  (interactive "*p")
  (let ((use-region (use-region-p)))
    (save-excursion
      (let ((text (if use-region        ;Get region if active, otherwise line
                      (buffer-substring (region-beginning) (region-end))
                    (prog1 (thing-at-point 'line)
                      (end-of-line)
                      (if (< 0 (forward-line 1)) ;Go to beginning of next line, or make a new one
                          (newline))))))
        (dotimes (i (abs (or n 1)))     ;Insert N times, or once if not specified
          (insert text))))
    (if use-region nil                  ;Only if we're working with a line (not a region)
      (let ((pos (- (point) (line-beginning-position)))) ;Save column
        (if (> 0 n)                             ;Comment out original with negative arg
            (comment-region (line-beginning-position) (line-end-position)))
        (forward-line 1)
        (forward-char pos)))))

(defun increment (n) (interactive "p")
 ;; Increment the number after point.  With an argument, add that much.
 (let (val)
   (delete-region
    (point)
    (progn
      (setq val (read (current-buffer)))
      (if (not (numberp val)) (error "Not in front of a number"))
      (point)))
   (insert (int-to-string (+ val n)))))
(global-set-key "\C-c+" 'increment)

;; Macro way
;; from insert-kbd-macro
(fset 'ucase_between_quotes
   (lambda (&optional arg) "Keyboard macro." (interactive "p") (kmacro-exec-ring-item (quote ([18 34 67108896 19 34 19 24 21] 0 "%d")) arg)))

;;;  Create a thing type for double-quote delimited "string"
(put 'string 'bounds-of-thing-at-point
     (lambda () (thing-at-point-bounds-of-delimited-thing-at-point "\"")))

(defun dkh/select_q_string_region ()
  "Select the region of string at point"
  (interactive)
  (thing-region "string"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Get IP Address
;; http://emacs-fu.blogspot.com/2009/05/getting-your-ip-address.html
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun get-ip-address (&optional dev)
  "get the IP-address for device DEV (default: eth0)"
  (interactive)
  (let ((dev (if dev dev "eth0")))
    (format-network-address (car (network-interface-info dev)) t)))

;; http://snipplr.com/view.php?codeview&id=34032

(defun get-ip-addresses ()
  "Returns the current system IPv4 addresses as a list of
strings"
  (let* ((start 0)
; (match-positions ())
(ip-re "[1-9][0-9]?[0-9]?\.[1-9][0-9]?[0-9]?\.[1-9][0-9]?[0-9]?\.[1-9][0-9]?[0-9]?")
;; The rest of these variables try to make this platform agnostic.
;; Add more on to the cond statements if you need
(ipconfig (cond ((eq system-type 'windows-nt)
"ipconfig")
((eq system-type 'gnu/linux)
"/sbin/ifconfig")
((eq system-type 'darwin)
"/sbin/ifconfig")
(t (error "Don't know how to get-ip-address for %s"
system-type))))
(line-re (cond ((eq system-type 'windows-nt)
"IPv4 Address.*")
((eq system-type 'gnu/linux)
(concat "inet addr:" ip-re))
((eq system-type 'darwin)
(concat "inet " ip-re))
(t (error "Don't know how regex out ip line for %s"
system-type))))
;; I lied, not all of the rest of the variables are to make it
;; platform agnostic. This is where we grab the output
(output (shell-command-to-string ipconfig)))

    ;; The inner loop is a bit funky since I can't seem to get it to behave
    ;; exactly like Common Lisp
    (loop for pos in
(loop named inner
with match-positions = ()
do (let ((ret (string-match line-re output start)))
(if ret
(setq start (1+ ret))
(return-from inner match-positions))
(setq match-positions
(append match-positions (list ret)))))
collect (progn
(string-match ip-re output pos)
(match-string 0 output)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Reload current file with position saved
;; http://www.thekidder.net/2008/10/21/emacs-reload-file/
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun reload-file ()
  (interactive)
  (let ((curr-scroll (window-vscroll)))
    (find-file (buffer-name))
    (set-window-vscroll nil curr-scroll)
    (message "Reloaded file")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Edit files as root
;; http://nflath.com/2009/08/tramp/
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun sudo-edit (&optional arg)
  (interactive "p")
  (if arg
      (find-file (concat "/sudo:root@localhost:" (ido-read-file-name "File: ")))
    (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))

(defun sudo-edit-current-file ()
  (interactive)
  (let ((pos (point)))
    (find-alternate-file
     (concat "/sudo:root@localhost:" (buffer-file-name (current-buffer))))
    (goto-char pos)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Rename a file and the buffer it's in at the same time
;; Via yeggeconf http://sites.google.com/site/steveyegge2/my-dot-emacs-file
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun rename-file-and-buffer ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (message "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
        (cond ((get-buffer new-name)
               (message "A buffer named '%s' already exists!" new-name))
              (t
               (rename-file name new-name 1)
               (rename-buffer new-name)
               (set-visited-file-name new-name)
               (set-buffer-modified-p nil)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Abort minibuffer when mousing
;; http://trey-jackson.blogspot.com/2010/04/emacs-tip-36-abort-minibuffer-when.html
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun stop-using-minibuffer ()
  "kill the minibuffer"
  (when (>= (recursion-depth) 1)
    (abort-recursive-edit)))

(add-hook 'mouse-leave-buffer-hook 'stop-using-minibuffer)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Random crap
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; http://www.emacswiki.org/emacs/ElispCookbook
(defun qdot/filter (condp lst)
    (delq nil
          (mapcar (lambda (x) (and (funcall condp x) x)) lst)))

;; http://stackoverflow.com/questions/2238418/emacs-lisp-how-to-get-buffer-major-mode
(defun qdot/buffer-mode (buffer-or-string)
  "Returns the major mode associated with a buffer."
  (save-excursion
     (set-buffer buffer-or-string)
     major-mode))

(defun qdot/open-in-browser()
  (interactive)
  (let ((filename (buffer-file-name)))
    (browse-url (concat "file://" filename))))

(defun eval-and-replace ()
  "Replace the preceding sexp with its value."
  (interactive)
  (backward-kill-sexp)
  (condition-case nil
      (prin1 (eval (read (current-kill 0)))
             (current-buffer))
    (error (message "Invalid expression")
           (insert (current-kill 0)))))

(defun shell-current-directory ()
  "Opens a shell in the current directory"
  (interactive)
  (shell (concat "shell-" default-directory "-shell" )))

;; http://blog.tuxicity.se/elisp/emacs/2010/11/16/delete-file-and-buffer-in-emacs.html
(defun delete-this-buffer-and-file ()
  "Removes file connected to current buffer and kills buffer."
  (interactive)
  (let ((filename (buffer-file-name))
        (buffer (current-buffer))
        (name (buffer-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file!" name)
      (when (yes-or-no-p "Are you sure you want to remove this file? ")
        (delete-file filename)
        (kill-buffer buffer)
        (message "File '%s' successfully removed" filename)))))

;; http://www.reddit.com/r/emacs/comments/jfrqm/what_does_your_tab_key_do/
(defun smart-tab ()
  "If mark is active, indents region. Else if point is at the end of a symbol,
expands it. Else indents the current line. Acts as normal in minibuffer."
  (interactive)
  (cond (mark-active (indent-region (region-beginning) (region-end)))
        ((and (looking-at "\\_>") (not (looking-at "end")))
         (hippie-expand nil))
        (t (indent-for-tab-command))))


(message (concat "0 " (buffer-name) "... Done"))

(defun cat-command ()
  "A command for cats."
  (interactive)
  (require 'animate)
  (let ((mouse "
           ___00
        ~~/____'>
          \"  \"")
        (h-pos (floor (/ (window-height) 2)))
        (contents (buffer-string))
        (mouse-buffer (generate-new-buffer "*mouse*")))
    (save-excursion
      (switch-to-buffer mouse-buffer)
      (insert contents)
      (setq truncate-lines t)
      (animate-string mouse h-pos 0)
      (dotimes (_ (window-width))
        (sit-for 0.01)
        (dotimes (n 3)
          (goto-line (+ h-pos n 2))
          (move-to-column 0)
          (insert " "))))
    (kill-buffer mouse-buffer)))

#+end_src

** toggle line spacing function

#+begin_src emacs-lisp :tangle no

(defun toggle-line-spacing ()
  "Toggle line spacing between no extra space to extra half line height."
  (interactive)
  (if (eq line-spacing nil)
      (setq-default line-spacing 0.5) ; add 0.5 height between lines
    (setq-default line-spacing nil)   ; no extra heigh between lines
    )
  (redraw-display))

#+end_src

** Insert filename function

#+begin_src emacs-lisp :tangle no

(defun my-insert-file-name (filename &optional args)
  "Insert name of file FILENAME into buffer after point.

Prefixed with \\[universal-argument], expand the file name to
its fully canocalized path.  See `expand-file-name'.

Prefixed with \\[negative-argument], use relative path to file
name from current directory, `default-directory'.  See
`file-relative-name'.

The default with no prefix is to insert the file name exactly as
it appears in the minibuffer prompt."
  ;; Based on insert-file in Emacs -- ashawley 20080926
  (interactive "*fInsert file name: \nP")
  (cond ((eq '- args)
         (insert (file-relative-name filename)))
        ((not (null args))
         (insert (expand-file-name filename)))
        (t
         (insert filename))))

(global-set-key (kbd "C-H-f") 'my-insert-file-name)

(autoload 'ffap-guesser "ffap")
(autoload 'ffap-read-file-or-url "ffap")

(defun my-replace-file-at-point (currfile newfile)
  "Replace CURRFILE at point with NEWFILE.

When interactive, CURRFILE will need to be confirmed by user
and will need to exist on the file system to be recognized,
unless it is a URL.

NEWFILE does not need to exist.  However, Emacs's minibuffer
completion can help if it needs to be.

Based on `ffap'."
  (interactive
   (let ((currfile (ffap-read-file-or-url "Replace filename: "
                                          (ffap-guesser))))
     (list currfile
           (ffap-read-file-or-url (format "Replace `%s' with: "
                                          currfile) currfile))))
  (save-match-data
    (if (or (looking-at (regexp-quote currfile))
            (let ((filelen (length currfile))
                  (opoint (point))
                  (limit (+ (point) (length currfile))))
              (save-excursion
                (goto-char (1- filelen))
                (and (search-forward currfile limit
                                     'noerror)
                     (< (match-beginning 0) opoint))
                     (>= (match-end 0) opoint))))
        (replace-match newfile)
      (error "No file at point to replace"))))

(global-set-key (kbd "C-H-v") 'my-replace-file-at-point)

(message "0 dkh-insert-filename... Done")

(defun get-relative-line-content (num)
  "Return the string content of line `num' relative to the current line"
  (save-excursion
    (forward-line num)
    (buffer-substring-no-properties
     (line-beginning-position) (line-end-position))))

(defun insert-line-same ()
  "Insert the content up to the first difference of the previous two lines."
  (interactive)
  (let* ((line1 (get-relative-line-content -2))
    (line2 (get-relative-line-content -1))
      (beg (current-column))
      (end (compare-strings line1 beg nil line2 beg nil)))
    (insert-string
     (substring line1 beg
            (if (integerp end)
                (+ beg (- (abs end) 1))
              (length line1))))))

#+end_src

** jwiegley functions
#+begin_src emacs-lisp :tangle no

(defun system-idle-time ()
  (with-temp-buffer
    (call-process "ioreg" nil (current-buffer) nil
                  "-c" "IOHIDSystem" "-d" "4" "-S")
    (goto-char (point-min))
    (and (re-search-forward "\"HIDIdleTime\" = \\([0-9]+\\)" nil t)
         (/ (float (string-to-number (match-string 1)))
            1000000000.0))))

(defun quickping (host)
  (= 0 (call-process "/sbin/ping" nil nil nil "-c1" "-W50" "-q" host)))

(defun align-code (beg end &optional arg)
  (interactive "rP")
  (if (null arg)
      (align beg end)
    (let ((end-mark (copy-marker end)))
      (indent-region beg end-mark nil)
      (align beg end-mark))))

(defun delete-indentation-forward ()
  (interactive)
  (delete-indentation t))

(defun mark-line (&optional arg)
  (interactive "p")
  (beginning-of-line)
  (let ((here (point)))
    (dotimes (i arg)
      (end-of-line))
    (set-mark (point))
    (goto-char here)))

(defun mark-sentence (&optional arg)
  (interactive "P")
  (backward-sentence)
  (mark-end-of-sentence arg))

(defun isearch-backward-other-window ()
  (interactive)
  (split-window-vertically)
  (call-interactively 'isearch-backward))

(defun isearch-forward-other-window ()
  (interactive)
  (split-window-vertically)
  (call-interactively 'isearch-forward))

(defun duplicate-line ()
  "Duplicate the line containing point."
  (interactive)
  (save-excursion
    (let (line-text)
      (goto-char (line-beginning-position))
      (let ((beg (point)))
        (goto-char (line-end-position))
        (setq line-text (buffer-substring beg (point))))
      (if (eobp)
          (insert ?\n)
        (forward-line))
      (open-line 1)
      (insert line-text))))

(defun refill-paragraph (arg)
  (interactive "*P")
  (let ((fun (if (memq major-mode '(c-mode c++-mode))
                 'c-fill-paragraph
               (or fill-paragraph-function
                   'fill-paragraph)))
        (width (if (numberp arg) arg))
        prefix beg end)
    (forward-paragraph 1)
    (setq end (copy-marker (- (point) 2)))
    (forward-line -1)
    (let ((b (point)))
      (skip-chars-forward "^A-Za-z0-9`'\"(")
      (setq prefix (buffer-substring-no-properties b (point))))
    (backward-paragraph 1)
    (if (eolp)
        (forward-char))
    (setq beg (point-marker))
    (delete-horizontal-space)
    (while (< (point) end)
      (delete-indentation 1)
      (end-of-line))
    (let ((fill-column (or width fill-column))
          (fill-prefix prefix))
      (if prefix
          (setq fill-column
                (- fill-column (* 2 (length prefix)))))
      (funcall fun nil)
      (goto-char beg)
      (insert prefix)
      (funcall fun nil))
    (goto-char (+ end 2))))


(defun delete-current-line (&optional arg)
  (interactive "p")
  (let ((here (point)))
    (beginning-of-line)
    (kill-line arg)
    (goto-char here)))

(defun do-eval-buffer ()
  (interactive)
  (call-interactively 'eval-buffer)
  (message "Buffer has been evaluated"))

(defun find-which (name)
  (interactive "sCommand name: ")
  (find-file-other-window
   (substring (shell-command-to-string (format "which %s" name)) 0 -1)))


(defun my-describe-symbol  (symbol &optional mode)
  (interactive
   (info-lookup-interactive-arguments 'symbol current-prefix-arg))
  (let (info-buf find-buf desc-buf cust-buf)
    (save-window-excursion
      (ignore-errors
        (info-lookup-symbol symbol mode)
        (setq info-buf (get-buffer "*info*")))
      (let ((sym (intern-soft symbol)))
        (when sym
          (if (functionp sym)
              (progn
                (find-function sym)
                (setq find-buf (current-buffer))
                (describe-function sym)
                (setq desc-buf (get-buffer "*Help*")))
            (find-variable sym)
            (setq find-buf (current-buffer))
            (describe-variable sym)
            (setq desc-buf (get-buffer "*Help*"))
            ;;(customize-variable sym)
            ;;(setq cust-buf (current-buffer))
            ))))

    (delete-other-windows)

    (flet ((switch-in-other-buffer
            (buf)
            (when buf
              (split-window-vertically)
              (switch-to-buffer-other-window buf))))
      (switch-to-buffer find-buf)
      (switch-in-other-buffer desc-buf)
      (switch-in-other-buffer info-buf)
      ;;(switch-in-other-buffer cust-buf)
      (balance-windows))))

(defun scratch ()
  (interactive)
  (let ((current-mode major-mode))
    (switch-to-buffer-other-window (get-buffer-create "*scratch*"))
    (goto-char (point-min))
    (when (looking-at ";")
      (forward-line 4)
      (delete-region (point-min) (point)))
    (goto-char (point-max))
    (if (eq current-mode 'emacs-lisp-mode)
        (funcall current-mode))))


#+end_src

** copy rectangle text to clipboard
#+begin_src emacs-lisp :tangle no


(defun copy-rectangle-to-clipboard (p1 p2)
  "Copy region as column (rectangle) to operating system's clipboard.
This command will also put the text in register 0. (see: `copy-to-register')"
  (interactive "r")
  (let ((x-select-enable-clipboard t))
    (copy-rectangle-to-register ?0 p1 p2)
    (kill-new
     (with-temp-buffer
       (insert-register ?0)
       (buffer-string) )) ) )

#+end_src
** Increase text macros
*** blow up text
#+begin_src emacs-lisp

(fset 'blow_up_text_plus_four
   [?\C-x ?\C-+ ?\C-x ?\C-+ ?\C-x ?\C-+ ?\C-x ?\C-+ ?\C-x])

(global-set-key (kbd "C-c 4") 'blow_up_text_plus_four)

#+end_src

* Value added packages
** Abbrev
I like abbrev cause it saves typing

#+begin_src emacs-lisp :tangle no

(setq abbrev-file-name "~/git/.emacs.d/.abbrev_defs")
(read-abbrev-file abbrev-file-name t)
(setq dabbrev-case-replace nil)  ; Preserve case when expanding

;;(setq abbrev-mode t)
;;(setq-default abbrev-mode t)

#+end_src


#+begin_src emacs-lisp :tangle no

(use-package abbrev
  :commands abbrev-mode
  :diminish abbrev-mode
  :init
  (hook-into-modes #'abbrev-mode '(text-mode-hook))

  :config
  (progn
   (if (file-exists-p abbrev-file-name)
       (quietly-read-abbrev-file))

   (add-hook 'expand-load-hook
             (lambda ()
               (add-hook 'expand-expand-hook 'indent-according-to-mode)
               (add-hook 'expand-jump-hook 'indent-according-to-mode)))))

#+end_src

** Ace-Jump
#+begin_src emacs-lisp :tangle no

(use-package ace-jump-mode
  :bind ("H-<return>" . ace-jump-mode))


#+end_src

** allout

#+begin_src emacs-lisp :tangle no

(use-package allout
  :diminish allout-mode
  :commands allout-mode
  :config
  (progn
    (defvar allout-unprefixed-keybindings nil)

    (defun my-allout-mode-hook ()
      (dolist (mapping '((?b . allout-hide-bodies)
                         (?c . allout-hide-current-entry)
                         (?l . allout-hide-current-leaves)
                         (?i . allout-show-current-branches)
                         (?e . allout-show-entry)
                         (?o . allout-show-to-offshoot)))
        (bind-key (concat (format-kbd-macro allout-command-prefix)
                          " " (char-to-string (car mapping)))
                  (cdr mapping)
                  allout-mode-map))

      (if (memq major-mode '(emacs-lisp-mode lisp-interaction-mode))
          (unbind-key "C-k" allout-mode-map)))

    (add-hook 'allout-mode-hook 'my-allout-mode-hook)))

#+end_src

** ascii

#+begin_src emacs-lisp :tangle no

(use-package ascii
  :commands ascii-on
  :init
  (progn
    (defun ascii-toggle ()
      (interactive)
      (if ascii-display
          (ascii-off)
        (ascii-on)))

    (bind-key "C-c e A" 'ascii-toggle)))

#+end_src

** archive-region

#+begin_src emacs-lisp :tangle no

(use-package archive-region
  :commands kill-region-or-archive-region
  :bind ("C-w" . kill-region-or-archive-region))

#+end_src

** auctex

#+begin_src emacs-lisp :tangle no

(use-package tex-site
  :load-path "site-lisp/auctex/preview/"
  :defines (latex-help-cmd-alist
            latex-help-file)
  ;; jww (2012-06-15): Do I want to use AucTeX for texinfo-mode?
  :mode ("\\.tex\\'" . latex-mode)
  :config
  (progn
    (defun latex-help-get-cmd-alist () ;corrected version:
      "Scoop up the commands in the index of the latex info manual.
   The values are saved in `latex-help-cmd-alist' for speed."
      ;; mm, does it contain any cached entries
      (if (not (assoc "\\begin" latex-help-cmd-alist))
          (save-window-excursion
            (setq latex-help-cmd-alist nil)
            (Info-goto-node (concat latex-help-file "Command Index"))
            (goto-char (point-max))
            (while (re-search-backward "^\\* \\(.+\\): *\\(.+\\)\\." nil t)
              (let ((key (buffer-substring (match-beginning 1) (match-end 1)))
                    (value (buffer-substring (match-beginning 2)
                                             (match-end 2))))
                (add-to-list 'latex-help-cmd-alist (cons key value))))))
      latex-help-cmd-alist)

    (use-package latex-mode
      :defer t
      :config
      (info-lookup-add-help :mode 'latex-mode
                            :regexp ".*"
                            :parse-rule "\\\\?[a-zA-Z]+\\|\\\\[^a-zA-Z]"
                            :doc-spec '(("(latex2e)Concept Index" )
                                        ("(latex2e)Command Index"))))))

#+end_src

** auto-complete

#+begin_src emacs-lisp :tangle no

(use-package auto-complete-config
  :commands auto-complete-mode
  :diminish auto-complete-mode
  :config
  (progn
    (ac-set-trigger-key "TAB")
    (setq ac-use-menu-map t)))

#+end_src

** Autorevert

whenever an external process changes a file underneath emacs, and
there was no unsaved changes in the corresponding buffer, just revert
its content to reflect what's on-disk.

#+begin_src emacs-lisp :tangle no

(use-package autorevert
  :commands auto-revert-mode
  :diminish auto-revert-mode
  :init
  (add-hook 'find-file-hook
            #'(lambda ()
                (auto-revert-mode 1))))

#+end_src

** backup-each-save

#+begin_src emacs-lisp :tangle no

(use-package backup-each-save
  :defer t
  :init
  (progn
    (autoload 'backup-each-save "backup-each-save")
    (add-hook 'after-save-hook 'backup-each-save))

  :config
  (progn
    (defun backup-each-save-filter (filename)
      (not (string-match
            (concat "\\(^/tmp\\|\\.emacs\\.d/data\\(-alt\\)?/"
                    "\\|\\.newsrc\\(\\.eld\\)?\\)")
            filename)))

    (setq backup-each-save-filter-function 'backup-each-save-filter)

    (defun my-dont-backup-files-p (filename)
      (unless (string-match filename "/\\(archive/sent/\\|recentf$\\)")
        (normal-backup-enable-predicate filename)))

    (setq backup-enable-predicate 'my-dont-backup-files-p)))

#+end_src

** bookmarks

#+begin_src emacs-lisp :tangle no

(setq bm-repository-file "~/git/.emacs.d/.bm-repository")


;; (setq bm-restore-repository-on-load t)
;;
;; ;; make bookmarks persistent as default
;; (setq-default bm-buffer-persistence t)
;;
;; ;; Loading the repository from file when on start up.
;; (add-hook' after-init-hook 'bm-repository-load)
;;
;; ;; Restoring bookmarks when on file find.
;; (add-hook 'find-file-hooks 'bm-buffer-restore)
;;
;; ;; Saving bookmark data on killing a buffer
;; (add-hook 'kill-buffer-hook 'bm-buffer-save)
;;
;; ;; Saving the repository to file when on exit.
;; ;; kill-buffer-hook is not called when emacs is killed, so we
;; ;; must save all bookmarks first.
;; (add-hook 'kill-emacs-hook '(lambda nil
;;                               (bm-buffer-save-all)
;;                               (bm-repository-save)))

(use-package bm
  :pre-init
  (progn
    (defvar ctl-period-breadcrumb-map)
    (define-prefix-command 'ctl-period-breadcrumb-map)
    (bind-key "C-. b" 'ctl-period-breadcrumb-map))

  :bind (("C-. b b" . bm-last-in-previous-buffer)
         ("C-. b f" . bm-first-in-next-buffer)
         ("C-. b g" . bm-previous)
         ("C-. b l" . bm-show-all)
         ("C-. b m" . bm-toggle)
         ("C-. b n" . bm-next)
         ("C-. b p" . bm-previous)))

#+end_src

** Bittlebee


[[http://emacs-fu.blogspot.com/2012/03/social-networking-with-bitlbee-and-erc.html][social networking with bitlbee and erc]]




*** The ICQ white pages

Ever wondered what this 938748324 person is that sends messages to
you. AFAIK bitlbee has no builtin support to query the white pages of
ICQ, therefore i quickly hacked up this one:

#+begin_src emacs-lisp :tangle no

(defun erc-cmd-ICQWHOIS (uin)
  "Queries icq-user with UIN `uin', and returns the result."
  (let* ((result (myerc-query-icq-user uin))
         (fname (cdr (assoc 'fname result)))
         (lname (cdr (assoc 'lname result)))
         (nick (cdr (assoc 'nick result))))
    (erc-display-message nil 'notice (current-buffer) (format "%s (%s %s)" nick fname lname))))

#+end_src

** Bookmarks
*** Bookmark locations

#+begin_src emacs-lisp :tangle no

(setq bookmark-default-file "~/git/.emacs.d/.emacs.bmk")

(setq bmkp-last-as-first-bookmark-file "~/git/.emacs.d/.emacs.bmk")

(setq bmkp-bmenu-state-file "~/git/.emacs.d/.emacs-bmk-bmenu-state.el")

#+end_src

*** Bookmark+

#+begin_src emacs-lisp :tangle no

(use-package bookmark
;;  :disabled t
  :defer t
  :config
  (progn
    (use-package bookmark+)

    (defun my-bookmark-set ()
      (interactive)
      (flet ((bmkp-completing-read-lax
              (prompt &optional default alist pred hist)
              (completing-read prompt alist pred nil nil hist default)))
        (call-interactively #'bookmark-set)))

    (bind-key "C-x r m" 'my-bookmark-set)))

#+end_src


** browse-kill-ring+

#+begin_src emacs-lisp :tangle no

(use-package browse-kill-ring+)

#+end_src

** color-moccur

#+begin_src emacs-lisp :tangle no


(let ((ad-redefinition-action 'accept))
  (use-package color-moccur
    :commands (isearch-moccur isearch-all)
    :bind ("M-s O" . moccur)
    :init
    (progn
      (bind-key "M-o" 'isearch-moccur isearch-mode-map)
      (bind-key "M-O" 'isearch-moccur-all isearch-mode-map))

    :config
    (use-package moccur-edit)))

#+end_src



** debbugs

#+begin_src emacs-lisp :tangle no

(use-package debbugs
  :commands (debbugs-gnu debbugs-gnu-search))

#+end_src

** dedicated

#+begin_src emacs-lisp :tangle no

(use-package dedicated
  :bind ("C-. d" . dedicated-mode))

#+end_src

** Dictem

#+begin_src emacs-lisp :tangle no

(setq dictem-server "localhost")
(require 'dictem)

;;  http://www.myrkr.in-berlin.de/dictionary/

; SEARCH = MATCH + DEFINE
; Ask for word, database and search strategy
; and show definitions found

; SHOW DB
; Show a list of databases provided by DICT server
(global-set-key "\C-c\M-b" 'dictem-run-show-databases)

(define-key dictem-mode-map [tab] 'dictem-next-link)
(define-key dictem-mode-map [(backtab)] 'dictem-previous-link)
(define-key dictem-mode-map [return] 'dictem-run-search)

(dictem-initialize)

(defun my-dictem-run-search ()
  "Look up definitions for word at point."
  (interactive)
  (dictem-run 'dictem-base-search "*" (thing-at-point 'word) ".")
  (other-window 1))

;;;###autoload

(defun rgr/synonyms()
 (interactive)
 (let* ((default (thing-at-point 'symbol))
        (term (read-string (format "Synonyms for (%s): "
                                   default) default)))
   (dictem-run
    'dictem-base-search
    "moby-thes" term "exact")))

(define-key mode-specific-map [?S] 'rgr/synonyms)

(dictem-initialize)

;; junk

;; moby-thes is not a valid database, use -D for a list
;; No matches found for "junk"

    ;; For creating hyperlinks on database names and found matches.
    ;; Click on them with `mouse-2'
(add-hook 'dictem-postprocess-match-hook
         'dictem-postprocess-match)

    ;; For highlighting the separator between the definitions found.
    ;; This also creates hyperlink on database names.
(add-hook 'dictem-postprocess-definition-hook
         'dictem-postprocess-definition-separator)

    ;; For creating hyperlinks in dictem buffer that contains definitions.
(add-hook 'dictem-postprocess-definition-hook
         'dictem-postprocess-definition-hyperlinks)

    ;; For creating hyperlinks in dictem buffer that contains information
    ;; about a database.
(add-hook 'dictem-postprocess-show-info-hook
         'dictem-postprocess-definition-hyperlinks)

(add-hook 'dictem-postprocess-definition-hook
         'dictem-postprocess-each-definition)



(define-key flyspell-mode-map (kbd "C-+") 'flyspell-check-previous-highlighted-word)
(define-key flyspell-mode-map (kbd "C-#") 'flyspell-auto-correct-previous-word)
(define-key flyspell-mode-map (kbd "S-<f2>") 'ispell-word)
(define-key flyspell-mode-map (kbd "C-<f2>") 'flyspell-auto-correct-previous-word)

(setq synonyms-file "~/.emacs.d/thesaurus/mthesaur.txt")
(setq synonyms-cache-file "~/.emacs.d/thesaurus/syn.cache")
(setq synonyms-match-more-flag nil)

(require 'synonyms)
(define-key mode-specific-map [?S] 'synonyms)

(define-key mode-specific-map [?s] 'dictem-run-search)


(define-key dictem-mode-map [tab] 'dictem-next-link)
(define-key dictem-mode-map [(backtab)] 'dictem-previous-link)

; For creating hyperlinks on database names
                                      ; and found matches.
                                      ; Click on them with mouse-2
(add-hook 'dictem-postprocess-match-hook
        'dictem-postprocess-match)

        ; For highlighting the separator between the definitions found.
        ; This also creates hyperlink on database names.
(add-hook 'dictem-postprocess-definition-hook
        'dictem-postprocess-definition-separator)

        ; For creating hyperlinks in dictem buffer
                                      ; that contains definitions.
(add-hook 'dictem-postprocess-definition-hook
        'dictem-postprocess-definition-hyperlinks)

        ; For creating hyperlinks in dictem buffer
        ; that contains information about a database.
(add-hook 'dictem-postprocess-show-info-hook
        'dictem-postprocess-definition-hyperlinks)


#+end_src

** diff-mode

#+begin_src emacs-lisp :tangle no

(use-package diff-mode
  :commands diff-mode
  :config
  (use-package diff-mode-))

#+end_src

** dired

#+begin_src emacs-lisp :tangle no

(use-package dired
  :defer t
  :config
  (progn
    (defun dired-package-initialize ()
      (unless (featurep 'dired-async)
        (use-package dired-x)
;;        (use-package dired-async)
        (use-package dired-sort-map)
        (use-package runner)

        (setq dired-use-ls-dired t)

        (bind-key "l" 'dired-up-directory dired-mode-map)

        (defun my-dired-switch-window ()
          (interactive)
          (if (eq major-mode 'sr-mode)
              (call-interactively #'sr-change-window)
            (call-interactively #'other-window)))

        (bind-key "<tab>" 'my-dired-switch-window dired-mode-map)

        (bind-key "M-!" 'async-shell-command dired-mode-map)
        (unbind-key "M-G" dired-mode-map)
        (unbind-key "M-s f" dired-mode-map)

        (defadvice dired-omit-startup (after diminish-dired-omit activate)
          "Make sure to remove \"Omit\" from the modeline."
          (diminish 'dired-omit-mode) dired-mode-map)

        (defadvice dired-next-line (around dired-next-line+ activate)
          "Replace current buffer if file is a directory."
          ad-do-it
          (while (and  (not  (eobp)) (not ad-return-value))
            (forward-line)
            (setq ad-return-value(dired-move-to-filename)))
          (when (eobp)
            (forward-line -1)
            (setq ad-return-value(dired-move-to-filename))))

        (defadvice dired-previous-line (around dired-previous-line+ activate)
          "Replace current buffer if file is a directory."
          ad-do-it
          (while (and  (not  (bobp)) (not ad-return-value))
            (forward-line -1)
            (setq ad-return-value(dired-move-to-filename)))
          (when (bobp)
            (call-interactively 'dired-next-line)))

        (defvar dired-omit-regexp-orig (symbol-function 'dired-omit-regexp))

        ;; Omit files that Git would ignore
        (defun dired-omit-regexp ()
          (let ((file (expand-file-name ".git"))
                parent-dir)
            (while (and (not (file-exists-p file))
                        (progn
                          (setq parent-dir
                                (file-name-directory
                                 (directory-file-name
                                  (file-name-directory file))))
                          ;; Give up if we are already at the root dir.
                          (not (string= (file-name-directory file)
                                        parent-dir))))
              ;; Move up to the parent dir and try again.
              (setq file (expand-file-name ".git" parent-dir)))
            ;; If we found a change log in a parent, use that.
            (if (file-exists-p file)
                (let ((regexp (funcall dired-omit-regexp-orig))
                      (omitted-files
                       (shell-command-to-string "git clean -d -x -n")))
                  (if (= 0 (length omitted-files))
                      regexp
                    (concat
                     regexp
                     (if (> (length regexp) 0)
                         "\\|" "")
                     "\\("
                     (mapconcat
                      #'(lambda (str)
                          (concat
                           "^"
                           (regexp-quote
                            (substring str 13
                                       (if (= ?/ (aref str (1- (length str))))
                                           (1- (length str))
                                         nil)))
                           "$"))
                      (split-string omitted-files "\n" t)
                      "\\|")
                     "\\)")))
              (funcall dired-omit-regexp-orig))))))

    (add-hook 'dired-mode-hook 'dired-package-initialize)

    (defun dired-double-jump (first-dir second-dir)
      (interactive
       (list (ido-read-directory-name "First directory: "
                                      (expand-file-name "~")
                                      nil nil "dl/")
             (ido-read-directory-name "Second directory: "
                                      (expand-file-name "~")
                                      nil nil "Archives/")))
      (dired first-dir)
      (dired-other-window second-dir))

    (bind-key "C-c J" 'dired-double-jump)))

#+end_src

** doxymacs

#+begin_src emacs-lisp :tangle no

(use-package doxymacs
  :disabled t
  :load-path "site-lisp/doxymacs/lisp/")

#+end_src

** ediff

#+begin_src emacs-lisp :tangle no

(use-package ediff
  :defer t
  :config
  (progn
    (defun ediff-keep-both ()
      (interactive)
      (with-current-buffer ediff-buffer-C
        (beginning-of-line)
        (assert (or (looking-at "<<<<<<")
                    (re-search-backward "^<<<<<<" nil t)
                    (re-search-forward "^<<<<<<" nil t)))
        (beginning-of-line)
        (let ((beg (point)))
          (forward-line)
          (delete-region beg (point))
          (re-search-forward "^>>>>>>>")
          (beginning-of-line)
          (setq beg (point))
          (forward-line)
          (delete-region beg (point))
          (re-search-forward "^#######")
          (beginning-of-line)
          (setq beg (point))
          (re-search-forward "^=======")
          (beginning-of-line)
          (forward-line)
          (delete-region beg (point)))))

    (add-hook 'ediff-keymap-setup-hook
              #'(lambda ()
                  (bind-key "c" 'ediff-keep-both ediff-mode-map)))

    (defun keep-mine ()
      (interactive)
      (beginning-of-line)
      (assert (or (looking-at "<<<<<<")
                  (re-search-backward "^<<<<<<" nil t)
                  (re-search-forward "^<<<<<<" nil t)))
      (goto-char (match-beginning 0))
      (let ((beg (point))
            (hashes (re-search-forward "^#######" (+ (point) 10000) t)))
        (forward-line)
        (delete-region beg (point))
        (re-search-forward (if hashes "^>>>>>>>" "^======="))
        (setq beg (match-beginning 0))
        (re-search-forward (if hashes "^=======" "^>>>>>>>"))
        (forward-line)
        (delete-region beg (point))))

    (defun keep-theirs ()
      (interactive)
      (beginning-of-line)
      (assert (or (looking-at "<<<<<<")
                  (re-search-backward "^<<<<<<" nil t)
                  (re-search-forward "^<<<<<<" nil t)))
      (goto-char (match-beginning 0))
      (let ((beg (point))
            (hashes (re-search-forward "^#######" (+ (point) 10000) t)))
        (re-search-forward (if hashes "^>>>>>>>" "^======="))
        (forward-line)
        (delete-region beg (point))
        (re-search-forward (if hashes "^#######" "^>>>>>>>"))
        (beginning-of-line)
        (setq beg (point))
        (when hashes
          (re-search-forward "^=======")
          (beginning-of-line))
        (forward-line)
        (delete-region beg (point))))

    (defun keep-both ()
      (interactive)
      (beginning-of-line)
      (assert (or (looking-at "<<<<<<")
                  (re-search-backward "^<<<<<<" nil t)
                  (re-search-forward "^<<<<<<" nil t)))
      (beginning-of-line)
      (let ((beg (point)))
        (forward-line)
        (delete-region beg (point))
        (re-search-forward "^>>>>>>>")
        (beginning-of-line)
        (setq beg (point))
        (forward-line)
        (delete-region beg (point))
        (re-search-forward "^#######")
        (beginning-of-line)
        (setq beg (point))
        (re-search-forward "^=======")
        (beginning-of-line)
        (forward-line)
        (delete-region beg (point))))))

#+end_src


** W3m

#+begin_src emacs-lisp :tangle no

(use-package w3m
  :commands w3m-browse-url
  :init
  (progn
;;    (setq w3m-command "/opt/local/bin/w3m")

    (autoload 'w3m-session-crash-recovery-remove "w3m-session")

    (defun wikipedia-query (term)
      (interactive (list (read-string "Wikipedia search: " (word-at-point))))
      (require 'w3m-search)
      (w3m-search "en.wikipedia" term))

    (eval-when-compile
      (autoload 'w3m-search-escape-query-string "w3m-search"))

    (defun wolfram-alpha-query (term)
      (interactive (list (read-string "Ask Wolfram Alpha: " (word-at-point))))
      (require 'w3m-search)
      (w3m-browse-url (format "http://m.wolframalpha.com/input/?i=%s"
                              (w3m-search-escape-query-string term))))

    (defun goto-emacswiki ()
      (interactive)
      (w3m-browse-url "http://www.emacswiki.org"))

    (bind-key "H-M-e" 'goto-emacswiki)
    (bind-key "H-M-g" 'w3m-search)
    (bind-key "H-M-h" 'wolfram-alpha-query)
    (bind-key "H-M-w" 'wikipedia-query))

  :config
  (let (proxy-host proxy-port)
    (with-temp-buffer
      (shell-command "scutil --proxy" (current-buffer))

      (when (re-search-forward "HTTPPort : \\([0-9]+\\)" nil t)
        (setq proxy-port (match-string 1)))
      (when (re-search-forward "HTTPProxy : \\(\\S-+\\)" nil t)
        (setq proxy-host (match-string 1))))

    (if (and proxy-host proxy-port)
        (setq w3m-command-arguments
              (nconc w3m-command-arguments
                     (list "-o" (format "http_proxy=http://%s:%s/"
                                        proxy-host proxy-port)))))

    (use-package w3m-type-ahead
      :requires w3m
      :init
      (add-hook 'w3m-mode-hook 'w3m-type-ahead-mode))

    (bind-key "<return>" 'w3m-view-url-with-external-browser
              w3m-minor-mode-map)))

#+end_src

*** For Gnus



#+begin_src emacs-lisp :tangle no

(setq apropos-url-alist
      '(("^gw?:? +\\(.*\\)" . ;; Google Web
         "http://www.google.com/search?q=\\1")

        ("^g!:? +\\(.*\\)" . ;; Google Lucky
         "http://www.google.com/search?btnI=I%27m+Feeling+Lucky&q=\\1")

        ("^gl:? +\\(.*\\)" .  ;; Google Linux
         "http://www.google.com/linux?q=\\1")

        ("^gi:? +\\(.*\\)" . ;; Google Images
         "http://images.google.com/images?sa=N&tab=wi&q=\\1")

        ("^gg:? +\\(.*\\)" . ;; Google Groups
         "http://groups.google.com/groups?q=\\1")

        ("^gd:? +\\(.*\\)" . ;; Google Directory
         "http://www.google.com/search?&sa=N&cat=gwd/Top&tab=gd&q=\\1")

        ("^gn:? +\\(.*\\)" . ;; Google News
         "http://news.google.com/news?sa=N&tab=dn&q=\\1")

        ("^gt:? +\\(\\w+\\)|? *\\(\\w+\\) +\\(\\w+://.*\\)" . ;; Google Translate URL
         "http://translate.google.com/translate?langpair=\\1|\\2&u=\\3")

        ("^gt:? +\\(\\w+\\)|? *\\(\\w+\\) +\\(.*\\)" . ;; Google Translate Text
         "http://translate.google.com/translate_t?langpair=\\1|\\2&text=\\3")

        ("^/\\.$" . ;; Slashdot
         "http://www.slashdot.org")

        ("^/\\.:? +\\(.*\\)" . ;; Slashdot search
         "http://www.osdn.com/osdnsearch.pl?site=Slashdot&query=\\1")

        ("^fm$" . ;; Freshmeat
         "http://www.freshmeat.net")

        ("^ewiki:? +\\(.*\\)" . ;; Emacs Wiki Search
         "http://www.emacswiki.org/cgi-bin/wiki?search=\\1")

        ("^ewiki$" . ;; Emacs Wiki
         "http://www.emacswiki.org")

        ("^arda$" . ;; The Encyclopedia of Arda
         "http://www.glyphweb.com/arda/")

         ))

(add-to-list 'apropos-url-alist '("^googledict:? +\\(\\w+\\)|? *\\(\\w+\\) +\\(.*\\)" . "http://www.google.com/dictionary?aq=f&langpair=\\1|\\2&q=\\3&hl=\\1"))
(add-to-list 'apropos-url-alist '("^ewiki2:? +\\(.*\\)" .  "http://www.google.com/cse?cx=004774160799092323420%3A6-ff2s0o6yi&q=\\1&sa=Search"))

(add-to-list 'apropos-url-alist '("^dpi:? +\\(.*\\)" . "http://api.drupal.org/api/search/7/\\1")) ;; Drupal API default to 7, api number if specified

(defun browse-apropos-url (text &optional new-window)
  (interactive (browse-url-interactive-arg "Location: "))
  (let ((text (replace-regexp-in-string
               "^ *\\| *$" ""
               (replace-regexp-in-string "[ \t\n]+" " " text))))
    (let ((url (assoc-default
                text apropos-url-alist
                '(lambda (a b) (let () (setq __braplast a) (string-match a b)))
                text)))
      (browse-url (replace-regexp-in-string __braplast url text) new-window))))

(defun browse-apropos-url-on-region (min max text &optional new-window)
  (interactive "r \nsAppend region to location: \nP")
  (browse-apropos-url (concat text " " (buffer-substring min max)) new-window))

;;(require 'browse-apropos-url)
;; (provide 'browse-url)



(defun rgr/browse-url (arg &optional url)
  "Browse the URL passed. Use a prefix arg for external default browser else use default browser which is probably W3m"
  (interactive "P")
  (setq url (or url (w3m-url-valid (w3m-anchor))
  (browse-url-url-at-point)
(thing-at-point 'word)
))
  (if rag
      (when url (browse-url-default-browser url))
    (if  url (browse-url url) (call-interactively 'browse-url))
    ))


(defun rgr/google(term)
  "Call google search for the specified term. Do not call if string is zero length."
  (let ((url (if (zerop (length term)) "http://www.google.com " (concat "gw: " term))))
    (browse-apropos-url url)))

(defun rgr/google-search-prompt()
  (interactive)
  (rgr/google (read-string "Google the web for the following phrase :
  "
(thing-at-point 'word)
)))

(add-to-list 'apropos-url-alist '("^googledict:? +\\(\\w+\\)|? *\\(\\w+\\) +\\(.*\\)" . "http://www.google.com/dictionary?aq=f&langpair=\\1|\\2&q=\\3&hl=\\1"))
(add-to-list 'apropos-url-alist '("^ewiki2:? +\\(.*\\)" .  "http://www.google.com/cse?cx=004774160799092323420%3A6-ff2s0o6yi&q=\\1&sa=Search"))


(defun rgr/call-google-translate (langpair prompt)
  (interactive)
  (let* ((thing (thing-at-point 'word) )
    )
    (setq thing (read-string (format prompt thing) nil nil thing))
    (browse-apropos-url  (concat (if (string-match " " thing) (quote "gt")(quote "googledict")) " " langpair " " thing))))

(defun rgr/browse-apropos-url (prefix prompt)
  (interactive)
  (let* ((thing (thing-at-point 'word))
    )
    (setq thing (read-string (format prompt thing) nil nil thing))
    (browse-apropos-url  (concat prefix " " thing))))

;; Search Google at point:
(defun my-search-google (w)
  "Launch google on the Word at Point"
  (interactive
   (list (let* ((word (thing-at-point 'symbol))
                (input (read-string (format "Google%s: "
                                (if (not word) "" (format " (default %s)" word))))))
           (if (string= input "") (if (not word)
                       (error "No keyword to search given") word) input) ;sinon input
           )))
  (browse-url (format "http:/www.google.com/search?q=%s" w))
  )

;; This buffer is for notes you don't want to save, and for Lisp evaluation.
;; If you want to create a file, visit that file with C-x C-f,
;; then enter the text in that file's own buffer.


(defun pm/region-or-word (prompt)
  "Read a string from the minibuffer, prompting with PROMPT.
If `transient-mark-mode' is non-nil and the mark is active,
it defaults to the current region, else to the word at or before
point. This function returns a list (string) for use in `interactive'."
  (list (read-string prompt (or (and transient-mark-mode mark-active
                                     (buffer-substring-no-properties
                                      (region-beginning) (region-end)))
                            (current-word)))))
(defun pm/google (string)
  "Ask a WWW browser to google string.
Prompts for a string, defaulting to the active region or the current word at
or before point."
  (interactive (pm/region-or-word "Google: "))
  (browse-url (concat "http://google.com/search?num=100&q=" string)))


(setq w3m-use-cookies t)

(setq w3m-coding-system 'utf-8
      w3m-file-coding-system 'utf-8
      w3m-file-name-coding-system 'utf-8
      w3m-input-coding-system 'utf-8
      w3m-output-coding-system 'utf-8
      w3m-terminal-coding-system 'utf-8)

(require 'org-w3m)

(setq browse-url-new-window-flag t)

(setq browse-url-browser-function 'w3m-browse-url-other-workgroup)

(defun w3m-browse-url-other-workgroup (url &optional newwin)
  (let ((w3m-pop-up-windows t))
   (wg-switch-to-index-5)
    (w3m-browse-url url newwin)))

(setq browse-url-generic-program "conkeror")

(defun rgr/browse (url)
  "If prefix is specified use the system default browser else use the configured emacs one"
  (if current-prefix-arg
;;      (when url (browse-url-default-browser url))
      (when url (browse-url-generic url))
    (if  url (browse-url url) (call-interactively 'browse-url))
    ))

(defun rgr/browse-url (&optional url)
  "browse the url passed in"
  (interactive)
  (setq url (or url (w3m-url-valid (w3m-anchor)) (browse-url-url-at-point) (region-or-word-at-point)))
  (setq url (read-string (format "Url \"%s\" :" url) url nil url))
  (rgr/browse url))

(global-set-key "\C-xm" 'browse-url-at-point)
(global-set-key (kbd "<f4>") 'rgr/browse-url)


 (defun w3m-add-keys ()
   (define-key w3m-mode-map "S" 'w3m-session-save)
   (define-key w3m-mode-map "L" 'w3m-session-load))
 (add-hook 'w3m-mode-hook 'w3m-add-keys)

(defun my-w3m-rename-buffer (url)
  "Renames the current buffer to be the current URL"
  (rename-buffer url t))
(add-hook 'w3m-display-hook 'my-w3m-rename-buffer)

(setq w3m-default-directory "~/.emacs.d/.w3m")

(message "0 dkh-w3m... Done")

(defun sacha/toggle-w3m ()
  (interactive)
  (let ((list (buffer-list))
        found
        (from-w3m (equal major-mode 'w3m-mode)))
    (while list
      (when (with-current-buffer (car list)
              (if from-w3m
                  (not (equal major-mode 'w3m-mode))
                (equal major-mode 'w3m-mode)))
        (setq found (car list))
        (pop-to-buffer (car list))
        (setq list nil))
      (setq list (cdr list)))
    (unless (or from-w3m found)
      (call-interactively 'w3m))))

;; http://www.mit.edu/afs/sipb/contrib/emacs/packages/w3m_el-1.2.8/w3m-filter.el
(defun sacha/w3m-filter-google (url &rest ignore)
  "Add <LINK> tag to search results of www.google.com."
  (goto-char (point-max))
  (let ((next (when (re-search-backward
                     "<a href=\\([^>]+\\)><img src=/\\(intl/[^/]+/\\)?nav_next.gif"
                     nil t)
                (match-string 1)))
        (perv (when (re-search-backward
                     "<a href=\\([^>]+\\)><img src=/\\(intl/[^/]+/\\)?nav_previous.gif"
                     nil t)
                (match-string 1))))
    (goto-char (point-min))
    (when (search-forward "<head>" nil t)
      (when prev (insert "\n<link rel=\"prev\" href=\"" prev "\">"))
      (when next (insert "\n<link rel=\"next\" href=\"" next "\">")))
    t))

(defun sacha/w3m-filter-clientcopia (url &rest ignore)
  "Add <LINK> tag to search results of www.clientcopia.com."
  (goto-char (point-max))
  (let* ((next (when (re-search-backward
                     "\\(quotes.php.id=[0-9]+\\).*NEXT"
                     nil t)
                (match-string 1)))
         (prev (when (re-search-backward
                     "<a href=\\(quotes.php.id=[0-9]+\\).*BACK"
                     nil t)
                (match-string 1))))
    (goto-char (point-min))
    (when (search-forward "<head>" nil t)
      (when prev (insert "\n<link rel=\"prev\" href=\"" prev "\">"))
      (when next (insert "\n<link rel=\"next\" href=\"" next "\">")))
    t))

;; Guessed
(defun w3m-filter-find-relationships (url next previous)
  "Add <LINK> tags if they don't yet exist."
  (let ((case-fold-search t))
    (goto-char (point-max))
    (when (re-search-backward next nil t)
      (when (re-search-backward "href=\"?\\([^\" \t\n]+\\)" nil t)
        (setq w3m-next-url (match-string 1))))
    (when (re-search-backward previous nil t)
      (when (re-search-backward "href=\"?\\([^\" \t\n]+\\)" nil t)
        (setq w3m-previous-url (match-string 1))))))

(defun w3m-download-with-wget ()
  (interactive)
  (let ((url (or (w3m-anchor) (w3m-image))))
    (if url
        (let ((proc (start-process "wget" (format "*wget %s*" url)
                                   "wget" "-x" "--passive-ftp" "-nv"
                                   "-P" "/home/sacha/notebook/mirrors" url)))
          (with-current-buffer (process-buffer proc)
            (erase-buffer))
          (set-process-sentinel proc (lambda (proc str)
                                       (message "wget download done"))))
      (message "Nothing to get"))))

(defun sacha/w3m-setup-keymap ()
  "Use my heavily customized map."
  (interactive)
  ;; Undefine this key and use the advice instead so that my ido doesn't get
  ;; overridden
  (define-key w3m-mode-map (kbd "C-x b") nil)
  (define-key w3m-mode-map "C" 'w3m-print-this-url)
  (define-key w3m-mode-map "a" 'sacha/delicious-url)
  (define-key w3m-mode-map "A" 'w3m-bookmark-add-current-url)
  (define-key w3m-mode-map "w" 'w3m-download-with-wget)
  (define-key w3m-mode-map "d" 'w3m-download-with-wget)
  (define-key w3m-mode-map "D" 'w3m-download-this-url)
  ;; Do not override my ever so handy ERC binding
  (define-key w3m-mode-map (kbd "C-c C-SPC") nil)
  (define-key w3m-mode-map "m" 'sacha/w3m-mirror-current-page)
  (define-key w3m-mode-map "M" 'sacha/w3m-mirror-link)
  ;; I use search much more often than the context history list, although
  ;; context is still cool.
  (define-key w3m-mode-map "!" 'sacha/w3m-mirror-current-page)
  (define-key w3m-mode-map "s" 'w3m-search)
  (define-key w3m-mode-map "h" 'w3m-history)
  (define-key w3m-mode-map "t" 'w3m-scroll-down-or-previous-url)
  (define-key w3m-mode-map "n" 'w3m-scroll-up-or-next-url)
  ;; I don't often w3m to edit pages, so I'm borrowing o and e (right
  ;; below , / . for tab navigation) for page navigation instead.
  (define-key w3m-mode-map "o" 'w3m-view-previous-page)
  (define-key w3m-mode-map "e" 'w3m-view-next-page)
  ;; i is a more useful mnemonic for toggling images
  (define-key w3m-mode-map "i" 'w3m-toggle-inline-image)
  (define-key w3m-mode-map "I" 'w3m-toggle-inline-images)
  ;; and X for closing the buffer
  (define-key w3m-mode-map "X" 'w3m-delete-buffer)
  (define-key w3m-mode-map "x" 'w3m-delete-buffer)
  (define-key w3m-mode-map "z" 'w3m-delete-buffer)
  ;; and b for bookmarks
  (define-key w3m-mode-map "b" 'w3m-bookmark-view)
  ;; I don't use the Qwerty keymap, so hjkl is useless for me
  ;; I'll use HTNS, though
  (define-key w3m-mode-map "H" 'backward-char)
  (define-key w3m-mode-map "T" 'previous-line)
  (define-key w3m-mode-map "N" 'next-line)
  (define-key w3m-mode-map "S" 'forward-char)
  ;; Browse in new sessions by default
  (define-key w3m-mode-map (kbd "RET") 'w3m-view-this-url-new-session)
  (define-key w3m-mode-map [(shift return)] 'w3m-view-this-url)
  (define-key w3m-mode-map "g" 'w3m-goto-url)
  (define-key w3m-mode-map "G" 'w3m-goto-url-new-session)
  ;; f for forward? I want to be able to follow links without removing
  ;; most of my fingers from home row. My fingers are too short to hit
  ;; Enter.
  (define-key w3m-mode-map "f" 'w3m-view-this-url-new-session)
  (define-key w3m-mode-map "F" 'w3m-view-this-url)
  ;; Use cursor keys to scroll
  (define-key w3m-mode-map [(left)] 'backward-char)
  (define-key w3m-mode-map [(right)] 'forward-char)
  (define-key w3m-mode-map [(shift left)] 'w3m-shift-right)
  (define-key w3m-mode-map [(shift right)] 'w3m-shift-left)
  ;; Which means I can now use , and . to switch pages
  (define-key w3m-mode-map "." 'w3m-next-buffer)
  (define-key w3m-mode-map "," 'w3m-previous-buffer)
  ;; IBM stuff
  (define-key w3m-mode-map "i" nil)
  (define-key w3m-mode-map "ib" 'sacha/ibm-blog)
  (define-key w3m-mode-map "id" 'sacha/dogear-url)
  (define-key w3m-mode-map "f" 'sacha/w3m-open-in-firefox)

  )

(setq w3m-keep-arrived-urls 5000)
(add-hook 'w3m-mode-hook 'sacha/w3m-setup-keymap)
;;(sacha/w3m-setup-keymap)

(defun sacha/w3m-open-in-firefox ()
  (interactive)
  (browse-url-firefox w3m-current-url))

(eval-after-load 'w3m
  '(progn
     (define-key w3m-mode-map "q" 'w3m-previous-buffer)
     (define-key w3m-mode-map "w" 'w3m-next-buffer)
     (define-key w3m-mode-map "x" 'w3m-close-window)))

#+end_src

*** Sometimes need to re-wrap page

http://emacs-w3m.namazu.org/ml/msg10827.html

#+begin_src emacs-lisp :tangle no

(add-hook 'w3m-mode-hook
          (lambda ()
            (define-key w3m-mode-map "L" 'w3m-page-fill)))

(defun w3m-page-fill ()
  (interactive)
  (let ((w3m-fill-column (min (cond
                               ((boundp 'mew-summary-wrap-lines-column)
                                mew-summary-wrap-lines-column)
                               ((boundp 'message-fill-column)
                                message-fill-column)
                               (t
                                fill-column))
                              (- (window-width) 5))))
    (if (eq last-command this-command)
        (let ((pos (point-marker))
              (buffer-read-only nil)
              (inhibit-read-only t)
              (after-change-functions nil)
              (inhibit-point-motion-hooks t)
              beg)
          (save-excursion
            (goto-char (point-min))
            (when (memq 'w3m-header-line-location-title
                        (get-text-property (point) 'face))
              (forward-line 1))
            (if (fboundp 'mew-wrap-lines)
                (mew-wrap-lines (point) (point-max))
              (fill-region (point) (point-max))))
          (goto-char pos))
      (w3m-redisplay-this-page))))

#+end_src

#+begin_src emacs-lisp :tangle no

(setq w3m-fill-column 120)

#+end_src


*** jwiegley settings

#+begin_src emacs-lisp :tangle no

(setq w3m-cookie-accept-bad-cookies (quote ask))
(setq w3m-fill-column 80)



#+end_src



** winner
A feature to preserve split pane configuration. Use 【Ctrl+c ←】 and
【Ctrl+c →】

#+begin_src emacs-lisp :tangle no

(use-package winner
  :diminish winner-mode
  :if (not noninteractive)
  :init
  (progn
    (winner-mode 1)

    (bind-key "M-N" 'winner-redo)
    (bind-key "M-P" 'winner-undo)))

#+end_src


** wrap-region

#+begin_src emacs-lisp :tangle no

(use-package wrap-region
  :commands wrap-region-mode
  :diminish wrap-region-mode
  :config
  (wrap-region-add-wrappers
   '(("$" "$")
     ("/" "/" nil ruby-mode)
     ("/* " " */" "#" (java-mode javascript-mode css-mode
                                 c-mode c++-mode))
     ("`" "`" nil (markdown-mode ruby-mode shell-script-mode)))))

#+end_src

** zencoding-mode

#+begin_src emacs-lisp :tangle no

(use-package zencoding-mode
  :commands zencoding-mode
  :init
  (progn
    (add-hook 'nxml-mode-hook 'zencoding-mode)
    (add-hook 'html-mode-hook 'zencoding-mode)
    (add-hook 'html-mode-hook
              #'(lambda ()
                (bind-key "<return>" 'newline-and-indent html-mode-map))))

  :config
  (progn
    (defvar zencoding-mode-keymap (make-sparse-keymap))
    (bind-key "C-c C-c" 'zencoding-expand-line zencoding-mode-keymap)))

#+end_src

* Programming (IDE)
** Magit

#+begin_src emacs-lisp :tangle no

(require 'magit)

(setq magit-repo-dirs (quote
(
        "/home/user/git/project"
        "/home/user/git/project2"
        "/su:user@localhost:/home/www/project1"
)))

#+end_src

** Comment Box

In a [[http://irreal.org/blog/?p%3D371#comment-1543][comment]] to my [[http://irreal.org/blog/?p%3D371][Emacs comment-box Revisited]] post, Aaron showed me a
nice way to deal with the boundaries of expanding regions. Recall that
in that post I wanted to pad the first line of a comment out to the
fill column so that comment-box would draw the box across the whole
width (more or less) of the window. The problem was that adding those
blanks increased the size of the region so the character number of the
end of the region was no longer correct. In my code that was easily
fixed because I could use (point-max) to locate the end of the region
since I had narrowed the buffer to the region.

Aaron’s way of handling this is nice because it feels less ad hoc and
because it works for any position in the buffer not just the beginning
or end. The idea is to use a marker to point at the end of the
region. Conceptually, a marker is just like a position (that is a
character index into the buffer) but it has the nice property that if
you change the size of the buffer, the marker is adjusted when
necessary. It’s as if you planted a flag at the position and the flag
moves as the buffer expands or contracts.

Here’s what the revised code looks like

#+begin_src emacs-lisp :tangle no
(defun jcs-comment-box (b e)
  "Draw a box comment around the region but arrange for the region
to extend to at least the fill column. Place the point after the
comment box."
  (interactive "r")
  (let ((e (copy-marker e t)))
    (goto-char b)
    (end-of-line)
    (insert-char ?  (- fill-column (current-column)))
    (comment-box b e 1)
    (goto-char e)
    (set-marker e nil)))

#+end_src

** Compilation settings

#+begin_src emacs-lisp :tangle no

(setq compilation-scroll-output 1)

;;; Shut up compile saves
(setq compilation-ask-about-save nil)
;;; Don't save *anything*
(setq compilation-save-buffers-predicate '(lambda () nil))

#+end_src



** camelCase

You can set emacs so that word moving commands will move cursor into
between CamelCaseWords. (word deletion behavior also changes
accordingly.)

To toggle it globally, call “global-subword-mode”. To set it for
current file only, call “subword-mode”. (subword mode is available in
Emacs 23.2)

To set it permanently, put one of the following in your emacs init
file:

#+begin_src emacs-lisp :tangle no

(subword-mode 1) ; 1 for on, 0 for off
(global-subword-mode 1) ; 1 for on, 0 for off

#+end_src


** Programming languages

#+begin_src emacs-lisp :tangle no

(require 'js-mode-expansions)
(require 'html-mode-expansions)
(require 'css-mode-expansions)

#+end_src

** Eclim

#+begin_src emacs-lisp :tangle no

(setq eclim-auto-save t) ;; very important (global-eclim-mode)

#+end_src

** Eproject

(require 'eproject)
(require 'eproject-extras)

(define-project-type web (generic)
;;  (look-for "plan.org")
  (look-for "admin.php")
  :relevant-files ("\\.php$" "\\.js$" "\\.org$" "\\.sql$" "\\.css$" "authinfo" "vhost"))

(add-hook 'web-project-file-visit-hook '(lambda ()
                      (ignore-errors
                        (message "Web Project : %s" eproject-root)
                        )))

(define-project-type emacs-config (generic)
  (look-for "starter-kit.org")
  :relevant-files ("\\.el$" "\\.org$" "\\.gpg$"))

(add-hook 'emacs-config-project-file-visit-hook '(lambda ()
                           (ignore-errors
                             (message "Emacs Configuration")
                             )))

;;  (define-project-type php-web (generic)
;;    (look-for "plan.org")
;;    :relevant-files ("\\.php$" "\\.css$" "authinfo" "vhost"))

;;  (add-hook 'php-web-project-file-visit-hook '(lambda ()
;;    (ignore-errors
;;      (message "PHP-WEB")
;;      )))

(defmacro .emacs-curry (function &rest args)
  `(lambda () (interactive)
     (,function ,@args)))

(defmacro .emacs-eproject-key (key command)
  (cons 'progn
        (loop for (k . p) in (list (cons key 4) (cons (upcase key) 1))
              collect
              `(global-set-key
                (kbd ,(format "C-x p %s" k))
                (.emacs-curry ,command ,p)))))

(.emacs-eproject-key "k" eproject-kill-project-buffers)
(.emacs-eproject-key "v" eproject-revisit-project)
(.emacs-eproject-key "b" eproject-ibuffer)
(.emacs-eproject-key "o" eproject-open-all-project-files)

#+end_src


** Etags

#+begin_src emacs-lisp :tangle no

(require 'etags-select)

;; list of file names of tags tables to search
(setq tags-table-list
      '(
"~/.emacs.d/TAGS"
        ))

#+end_src

*** TODO Etags with IDO

#+begin_src emacs-lisp :tangle no

(defun ido-find-tag ()
  "Find a tag using ido"
  (interactive)
  (tags-completion-table)
  (let (tag-names)
    (mapc (lambda (x)
        (unless (integerp x)
          (push (prin1-to-string x t) tag-names)))
      tags-completion-table)
    (find-tag (ido-completing-read "Tag: " tag-names))))

(defun ido-find-file-in-tag-files ()
  (interactive)
  (save-excursion
    (let ((enable-recursive-minibuffers t))
      (visit-tags-table-buffer))
    (find-file
     (expand-file-name
      (ido-completing-read
       "Project file: " (tags-table-files) nil t)))))

(global-set-key [remap find-tag] 'ido-find-tag)
(global-set-key (kbd "H-.") 'ido-find-file-in-tag-files)

(defun pm/find-tags-file ()
  "Recursively searches each parent directory for a file named `TAGS'
   and returns the path to that file or nil if a tags file is not found.
   Returns nil if the buffer is not visiting a file.
   (from jds-find-tags-file in the emacs-wiki)"
  (labels ((find-tags-file-r
            (path)
            (let* ((parent (if path (file-name-directory path)
                             default-directory))
                   (possible-tags-file (concat parent "TAGS")))
              (cond
               ((file-exists-p possible-tags-file)
                (shell-command (concat "make -C" parent " TAGS"))
                (throw 'found-it possible-tags-file))
               ((string= "/TAGS" possible-tags-file)
                (error "no tags file found"))
               (t
                (find-tags-file-r (directory-file-name parent)))))))
    (catch 'found-it
      (find-tags-file-r (buffer-file-name)))))

(defadvice find-tag (before pm/before-find-tag activate)
  (setq tags-file-name (pm/find-tags-file)))

#+end_src

** Generic X (for Apache logs)

#+begin_src emacs-lisp :tangle no

(require 'generic-x)

(define-generic-mode 'htaccess-mode
  '(?#)
  '(;; core
    "AcceptPathInfo" "AccessFileName" "AddDefaultCharset" "AddOutputFilterByType"
    "AllowEncodedSlashes" "AllowOverride" "AuthName" "AuthType"
    "CGIMapExtension" "ContentDigest" "DefaultType" "DocumentRoot"
    "EnableMMAP" "EnableSendfile" "ErrorDocument" "ErrorLog"
    "FileETag" "ForceType" "HostnameLookups" "IdentityCheck"
    "Include" "KeepAlive" "KeepAliveTimeout" "LimitInternalRecursion"
    "LimitRequestBody" "LimitRequestFields" "LimitRequestFieldSize" "LimitRequestLine"
    "LimitXMLRequestBody" "LogLevel" "MaxKeepAliveRequests" "NameVirtualHost"
    "Options" "Require" "RLimitCPU" "RLimitMEM"
    "RLimitNPROC" "Satisfy" "ScriptInterpreterSource" "ServerAdmin"
    "ServerAlias" "ServerName" "ServerPath" "ServerRoot"
    "ServerSignature" "ServerTokens" "SetHandler" "SetInputFilter"
    "SetOutputFilter" "TimeOut" "UseCanonicalName"
    ;; .htaccess tutorial
    "AddHandler" "AuthUserFile" "AuthGroupFile"
    ;; mod_rewrite
    "RewriteBase" "RewriteCond" "RewriteEngine" "RewriteLock" "RewriteLog"
    "RewriteLogLevel" "RewriteMap" "RewriteOptions" "RewriteRule"
    ;; mod_alias
    "Alias" "AliasMatch" "Redirect" "RedirectMatch" "RedirectPermanent"
    "RedirectTemp" "ScriptAlias" "ScriptAliasMatch")
  '(("%{\\([A-Z_]+\\)}" 1 font-lock-variable-name-face)
    ("\\b[0-9][0-9][0-9]\\b" . font-lock-constant-face)
    ("\\[.*\\]" . font-lock-type-face))
  '(".htaccess\\'")
  nil
  "Generic mode for Apache .htaccess files.")

(add-to-list 'auto-mode-alist '("\\.htaccess\\'" . htaccess-mode))

#+end_src

** HTML MODE

#+begin_src emacs-lisp :tangle no

(defun my-html-mode-setup ()
(auto-fill-mode -1))
(add-hook 'html-mode-hook 'my-html-mode-setup)

(defun prettify-key-sequence (&optional omit-brackets)
    "Markup a key sequence for pretty display in HTML.
  If OMIT-BRACKETS is non-null then don't include the key sequence brackets."
    (interactive "P")
    (let* ((seq (thing-at-point 'symbol))
           (key-seq (elt seq 0))
           (beg (elt seq 1))
           (end (elt seq 2))
           (key-seq-map (list (key "Ctrl") (key "Meta") (key "Shift")
                              (key "Tab") (key "Alt") (key "Esc")
                              (key "Enter") (key "Return") (key "Backspace")
                              (key "Delete") (key "F10") (key "F11")
                              (key "F12") (key "F2") (key "F3")
                              (key "F4") (key "F5") (key "F6") (key "F7")
                              (key "F8") (key "F9")
                              ;; Disambiguate F1
                              '("\\`F1" . "@<span class=\"key\">F1@</span>")
                              '("\\([^>]\\)F1" .
                                "\\1@<span class=\"key\">F1@</span>")
                              ;; Symbol on key
                              '("Opt" . "@<span class=\"key\">⌥ Opt@</span>")
                              '("Cmd" . "@<span class=\"key\">⌘ Cmd@</span>")
                              ;; Combining rules
                              '("\+\\(.\\) \\(.\\)\\'" .
                                "+@<span class=\"key\">\\1@</span> @<span class=\"key\">\\2@</span>")
                              '("\+\\(.\\) \\(.\\) " .
                                "+@<span class=\"key\">\\1@</span> @<span class=\"key\">\\2@</span> ")
                              '("\+\\(.\\) " .
                                "+@<span class=\"key\">\\1@</span> ")
                              '("\+\\(.\\)\\'" .
                                "+@<span class=\"key\">\\1@</span>"))))
      (mapc (lambda (m) (setq key-seq (replace-regexp-in-string
                                       (car m) (cdr m) key-seq t)))
            key-seq-map)
      ;; Single key
      (if (= (length key-seq) 1)
          (setq key-seq (concat "@<span class=\"key\">" key-seq "@</span>")))
      (delete-region beg end)
      (if omit-brackets
          (insert key-seq)
        (insert (concat "【" key-seq "】")))))

(defalias 'pks 'prettify-key-sequence)

(defun open-in-desktop ()
  "Open the current file in desktop.
Works in Microsoft Windows, Mac OS X, Linux."
  (interactive)
  (cond
   ((string-equal system-type "windows-nt")
    (w32-shell-execute "explore" (replace-regexp-in-string "/" "\\" default-directory t t)))
   ((string-equal system-type "darwin") (shell-command "open ."))
   ((string-equal system-type "gnu/linux") (shell-command "xdg-open ."))
   ) )

(global-set-key (kbd "<f7>") 'open-in-desktop)


#+end_src

** JavaScript

#+begin_src emacs-lisp :tangle no

(starter-kit-load "js")

#+end_src

** PSVN (subversion)

#+begin_src emacs-lisp :tangle no

;;; psvn
(setq svn-status-prefix-key '[(hyper s)])
(require 'psvn)
(define-key svn-log-edit-mode-map [f6] 'svn-log-edit-svn-diff)

(defun xsteve-svn-log-edit-setup ()
  (setq ispell-local-dictionary "english")
  (auto-fill-mode 1))

(add-hook 'svn-log-edit-mode-hook 'xsteve-svn-log-edit-setup)

#+end_src

** Yas

#+begin_src emacs-lisp :tangle no

(yas/load-directory "~/git/.emacs.d/snippets2")

(yas/load-directory "~/git/.emacs.d/snippets")

(yas/define-snippets 'text-mode
             '(("email" "me@google.com" "(user's email)" nil nil nil nil nil)
               ("phone" "777-777-7777" "(phone numer)" nil nil nil nil nil)
               ("thanks" "Thanks. Let me know if you have any questions or concerns" "(salutation)" nil nil nil nil nil)
               ("time" "`(current-time-string)`" "(current time)" nil nil nil nil nil))
             'nil)

(setq yas/indent-line nil)

#+end_src

** ECB

#+begin_src emacs-lisp :tangle no

;;(require 'cedet)

(add-hook 'ecb-deactivate-hook
      '(lambda ()
         (ecb-disable-advices 'ecb-winman-not-supported-function-advices t)))

#+end_src

** Stack Exchange mode

#+begin_src emacs-lisp :tangle no

;; Integrate Emacs with Stack Exchange http://stackoverflow.com/a/10386560/789593
(add-to-list 'auto-mode-alist '("\\(stack\\(exchange\\|overflow\\)\\|superuser\\|askubuntu\\)\\.com\\.[a-z0-9]+\\.txt" . markdown-mode))

#+end_src

** Glasses mode
#+begin_src emacs-lisp :tangle no

;; face to be put on capitals of an identifier looked through glasses
(setq glasses-face 'bold)

;; string to be displayed as a visual separator in unreadable identifiers
(setq glasses-separator "")

#+end_src

** Quick Tip: Spaces instead of Tabs
[2011-10-14 Fri 14:06]

September 30th, 2007 by Ryan McGeary · 11 Comments

Tab characters used as indentation of source code is a pet peeve of
mine. Add this to your emacs initialization to make sure all
indentation uses spaces instead.

#+begin_src emacs-lisp :tangle no

;; I hate tabs!
;; let tabs indent 4 spaces
(setq-default indent-tabs-mode nil)
(setq default-tab-width 4)
(setq indent-line-function 'insert-tab)

#+end_src


** Semantic
#+begin_src emacs-lisp :tangle no

(setq semantic-load-turn-useful-things-on t)

#+end_src

* Unicode

#+begin_src emacs-lisp :tangle no
;; set unicode data file location. (used by what-cursor-position and describe-char)
(let ((x "~/git/.emacs.d/UnicodeData.txt"))
  (when (file-exists-p x)
    (setq describe-char-unicodedata-file x)))

(defun my-print-chars (&optional start end)
  (interactive "nstart: \nnend: ")
  (switch-to-buffer (get-buffer-create "*UNICODE*"))
  (erase-buffer)
  (let ( (i start) )
    (while (<= i end)
      (insert (format "%s: U+%04x, %s\n" (char-to-string i) i (get-char-code-property i 'name)))
      (setq i (1+ i))
      )))

#+end_src

* Fun (random)
** life expectancy

(setq sacha/life-expectancy 90)
(setq sacha/birth-date '(05 12 1971))
(defun sacha/memento-mori ()
  (interactive)
  (let* ((expected (list
                    (elt sacha/birth-date 0)
                    (elt sacha/birth-date 1)
                    (+ (elt sacha/birth-date 2) sacha/life-expectancy)))
       (days-left (- (calendar-absolute-from-gregorian expected)
                     (time-to-days (current-time)))))
    (message "~ %d years or %d months or %d weeks left; make the most of them!"
             (/ days-left 365)
             (/ days-left 30)
             (/ days-left 7))))

#+end_src
